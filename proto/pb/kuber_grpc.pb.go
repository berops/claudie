// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.1
// source: kuber.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KuberService_RemoveLBScrapeConfig_FullMethodName      = "/claudie.KuberService/RemoveLBScrapeConfig"
	KuberService_StoreLBScrapeConfig_FullMethodName       = "/claudie.KuberService/StoreLBScrapeConfig"
	KuberService_StoreClusterMetadata_FullMethodName      = "/claudie.KuberService/StoreClusterMetadata"
	KuberService_DeleteClusterMetadata_FullMethodName     = "/claudie.KuberService/DeleteClusterMetadata"
	KuberService_SetUpStorage_FullMethodName              = "/claudie.KuberService/SetUpStorage"
	KuberService_StoreKubeconfig_FullMethodName           = "/claudie.KuberService/StoreKubeconfig"
	KuberService_DeleteKubeconfig_FullMethodName          = "/claudie.KuberService/DeleteKubeconfig"
	KuberService_DeleteNodes_FullMethodName               = "/claudie.KuberService/DeleteNodes"
	KuberService_PatchNodes_FullMethodName                = "/claudie.KuberService/PatchNodes"
	KuberService_SetUpClusterAutoscaler_FullMethodName    = "/claudie.KuberService/SetUpClusterAutoscaler"
	KuberService_DestroyClusterAutoscaler_FullMethodName  = "/claudie.KuberService/DestroyClusterAutoscaler"
	KuberService_PatchClusterInfoConfigMap_FullMethodName = "/claudie.KuberService/PatchClusterInfoConfigMap"
	KuberService_PatchKubeProxyConfigMap_FullMethodName   = "/claudie.KuberService/PatchKubeProxyConfigMap"
	KuberService_CiliumRolloutRestart_FullMethodName      = "/claudie.KuberService/CiliumRolloutRestart"
)

// KuberServiceClient is the client API for KuberService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KuberServiceClient interface {
	// RemoveLBScrapeConfig removes scrape config for every LB detached from this
	// cluster.
	RemoveLBScrapeConfig(ctx context.Context, in *RemoveLBScrapeConfigRequest, opts ...grpc.CallOption) (*RemoveLBScrapeConfigResponse, error)
	// StoreLBScrapeConfig stores scrape config for every LB attached to this
	// cluster.
	StoreLBScrapeConfig(ctx context.Context, in *StoreLBScrapeConfigRequest, opts ...grpc.CallOption) (*StoreLBScrapeConfigResponse, error)
	// StoreClusterMetadata creates a secret, which holds the private key and a
	// list of public IP addresses of the cluster supplied.
	StoreClusterMetadata(ctx context.Context, in *StoreClusterMetadataRequest, opts ...grpc.CallOption) (*StoreClusterMetadataResponse, error)
	// DeleteClusterMetadata deletes the secret holding the private key and public
	// IP addresses of the cluster supplied.
	DeleteClusterMetadata(ctx context.Context, in *DeleteClusterMetadataRequest, opts ...grpc.CallOption) (*DeleteClusterMetadataResponse, error)
	// SetUpStorage installs Longhorn into the cluster.
	SetUpStorage(ctx context.Context, in *SetUpStorageRequest, opts ...grpc.CallOption) (*SetUpStorageResponse, error)
	// StoreKubeconfig creates a secret, which holds the kubeconfig of a
	// Claudie-created cluster.
	StoreKubeconfig(ctx context.Context, in *StoreKubeconfigRequest, opts ...grpc.CallOption) (*StoreKubeconfigResponse, error)
	// DeleteKubeconfig removes the secret that holds the kubeconfig of a
	// Claudie-created cluster.
	DeleteKubeconfig(ctx context.Context, in *DeleteKubeconfigRequest, opts ...grpc.CallOption) (*DeleteKubeconfigResponse, error)
	// DeleteNodes deletes the specified nodes from a k8s cluster.
	DeleteNodes(ctx context.Context, in *DeleteNodesRequest, opts ...grpc.CallOption) (*DeleteNodesResponse, error)
	// PatchNodes applies attributes like providerID, labels or taints to the
	// nodes.
	PatchNodes(ctx context.Context, in *PatchNodesRequest, opts ...grpc.CallOption) (*PatchNodesResponse, error)
	// SetUpClusterAutoscaler deploys Cluster Autoscaler and Autoscaler Adapter
	// for every cluster specified.
	SetUpClusterAutoscaler(ctx context.Context, in *SetUpClusterAutoscalerRequest, opts ...grpc.CallOption) (*SetUpClusterAutoscalerResponse, error)
	// DestroyClusterAutoscaler deletes Cluster Autoscaler and Autoscaler Adapter
	// for every cluster specified.
	DestroyClusterAutoscaler(ctx context.Context, in *DestroyClusterAutoscalerRequest, opts ...grpc.CallOption) (*DestroyClusterAutoscalerResponse, error)
	// PatchClusterInfoConfigMap updates the cluster-info config map in the
	// kube-public namespace with the the kubeconfig. This needs to be done after
	// an api endpoint change as the config map in the kube-public namespace is
	// used by kubeadm when joining.
	PatchClusterInfoConfigMap(ctx context.Context, in *PatchClusterInfoConfigMapRequest, opts ...grpc.CallOption) (*PatchClusterInfoConfigMapResponse, error)
	// PatchCubeProxyConfigMap updates the kube-proxy config map with the value of
	// the server: from the passed in kubeconfig and subsequently restarts all
	// kube-proxy pods in the kube-system namespace. This change needs to be done
	// after a endpoint change is performed.
	PatchKubeProxyConfigMap(ctx context.Context, in *PatchKubeProxyConfigMapRequest, opts ...grpc.CallOption) (*PatchKubeProxyConfigMapResponse, error)
	// CiliumRolloutRestart performs a rollout restart of the cilium daemonset.
	CiliumRolloutRestart(ctx context.Context, in *CiliumRolloutRestartRequest, opts ...grpc.CallOption) (*CiliumRolloutRestartResponse, error)
}

type kuberServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKuberServiceClient(cc grpc.ClientConnInterface) KuberServiceClient {
	return &kuberServiceClient{cc}
}

func (c *kuberServiceClient) RemoveLBScrapeConfig(ctx context.Context, in *RemoveLBScrapeConfigRequest, opts ...grpc.CallOption) (*RemoveLBScrapeConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveLBScrapeConfigResponse)
	err := c.cc.Invoke(ctx, KuberService_RemoveLBScrapeConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) StoreLBScrapeConfig(ctx context.Context, in *StoreLBScrapeConfigRequest, opts ...grpc.CallOption) (*StoreLBScrapeConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreLBScrapeConfigResponse)
	err := c.cc.Invoke(ctx, KuberService_StoreLBScrapeConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) StoreClusterMetadata(ctx context.Context, in *StoreClusterMetadataRequest, opts ...grpc.CallOption) (*StoreClusterMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreClusterMetadataResponse)
	err := c.cc.Invoke(ctx, KuberService_StoreClusterMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) DeleteClusterMetadata(ctx context.Context, in *DeleteClusterMetadataRequest, opts ...grpc.CallOption) (*DeleteClusterMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClusterMetadataResponse)
	err := c.cc.Invoke(ctx, KuberService_DeleteClusterMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) SetUpStorage(ctx context.Context, in *SetUpStorageRequest, opts ...grpc.CallOption) (*SetUpStorageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUpStorageResponse)
	err := c.cc.Invoke(ctx, KuberService_SetUpStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) StoreKubeconfig(ctx context.Context, in *StoreKubeconfigRequest, opts ...grpc.CallOption) (*StoreKubeconfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreKubeconfigResponse)
	err := c.cc.Invoke(ctx, KuberService_StoreKubeconfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) DeleteKubeconfig(ctx context.Context, in *DeleteKubeconfigRequest, opts ...grpc.CallOption) (*DeleteKubeconfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteKubeconfigResponse)
	err := c.cc.Invoke(ctx, KuberService_DeleteKubeconfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) DeleteNodes(ctx context.Context, in *DeleteNodesRequest, opts ...grpc.CallOption) (*DeleteNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteNodesResponse)
	err := c.cc.Invoke(ctx, KuberService_DeleteNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) PatchNodes(ctx context.Context, in *PatchNodesRequest, opts ...grpc.CallOption) (*PatchNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchNodesResponse)
	err := c.cc.Invoke(ctx, KuberService_PatchNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) SetUpClusterAutoscaler(ctx context.Context, in *SetUpClusterAutoscalerRequest, opts ...grpc.CallOption) (*SetUpClusterAutoscalerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUpClusterAutoscalerResponse)
	err := c.cc.Invoke(ctx, KuberService_SetUpClusterAutoscaler_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) DestroyClusterAutoscaler(ctx context.Context, in *DestroyClusterAutoscalerRequest, opts ...grpc.CallOption) (*DestroyClusterAutoscalerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyClusterAutoscalerResponse)
	err := c.cc.Invoke(ctx, KuberService_DestroyClusterAutoscaler_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) PatchClusterInfoConfigMap(ctx context.Context, in *PatchClusterInfoConfigMapRequest, opts ...grpc.CallOption) (*PatchClusterInfoConfigMapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchClusterInfoConfigMapResponse)
	err := c.cc.Invoke(ctx, KuberService_PatchClusterInfoConfigMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) PatchKubeProxyConfigMap(ctx context.Context, in *PatchKubeProxyConfigMapRequest, opts ...grpc.CallOption) (*PatchKubeProxyConfigMapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchKubeProxyConfigMapResponse)
	err := c.cc.Invoke(ctx, KuberService_PatchKubeProxyConfigMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kuberServiceClient) CiliumRolloutRestart(ctx context.Context, in *CiliumRolloutRestartRequest, opts ...grpc.CallOption) (*CiliumRolloutRestartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CiliumRolloutRestartResponse)
	err := c.cc.Invoke(ctx, KuberService_CiliumRolloutRestart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KuberServiceServer is the server API for KuberService service.
// All implementations must embed UnimplementedKuberServiceServer
// for forward compatibility.
type KuberServiceServer interface {
	// RemoveLBScrapeConfig removes scrape config for every LB detached from this
	// cluster.
	RemoveLBScrapeConfig(context.Context, *RemoveLBScrapeConfigRequest) (*RemoveLBScrapeConfigResponse, error)
	// StoreLBScrapeConfig stores scrape config for every LB attached to this
	// cluster.
	StoreLBScrapeConfig(context.Context, *StoreLBScrapeConfigRequest) (*StoreLBScrapeConfigResponse, error)
	// StoreClusterMetadata creates a secret, which holds the private key and a
	// list of public IP addresses of the cluster supplied.
	StoreClusterMetadata(context.Context, *StoreClusterMetadataRequest) (*StoreClusterMetadataResponse, error)
	// DeleteClusterMetadata deletes the secret holding the private key and public
	// IP addresses of the cluster supplied.
	DeleteClusterMetadata(context.Context, *DeleteClusterMetadataRequest) (*DeleteClusterMetadataResponse, error)
	// SetUpStorage installs Longhorn into the cluster.
	SetUpStorage(context.Context, *SetUpStorageRequest) (*SetUpStorageResponse, error)
	// StoreKubeconfig creates a secret, which holds the kubeconfig of a
	// Claudie-created cluster.
	StoreKubeconfig(context.Context, *StoreKubeconfigRequest) (*StoreKubeconfigResponse, error)
	// DeleteKubeconfig removes the secret that holds the kubeconfig of a
	// Claudie-created cluster.
	DeleteKubeconfig(context.Context, *DeleteKubeconfigRequest) (*DeleteKubeconfigResponse, error)
	// DeleteNodes deletes the specified nodes from a k8s cluster.
	DeleteNodes(context.Context, *DeleteNodesRequest) (*DeleteNodesResponse, error)
	// PatchNodes applies attributes like providerID, labels or taints to the
	// nodes.
	PatchNodes(context.Context, *PatchNodesRequest) (*PatchNodesResponse, error)
	// SetUpClusterAutoscaler deploys Cluster Autoscaler and Autoscaler Adapter
	// for every cluster specified.
	SetUpClusterAutoscaler(context.Context, *SetUpClusterAutoscalerRequest) (*SetUpClusterAutoscalerResponse, error)
	// DestroyClusterAutoscaler deletes Cluster Autoscaler and Autoscaler Adapter
	// for every cluster specified.
	DestroyClusterAutoscaler(context.Context, *DestroyClusterAutoscalerRequest) (*DestroyClusterAutoscalerResponse, error)
	// PatchClusterInfoConfigMap updates the cluster-info config map in the
	// kube-public namespace with the the kubeconfig. This needs to be done after
	// an api endpoint change as the config map in the kube-public namespace is
	// used by kubeadm when joining.
	PatchClusterInfoConfigMap(context.Context, *PatchClusterInfoConfigMapRequest) (*PatchClusterInfoConfigMapResponse, error)
	// PatchCubeProxyConfigMap updates the kube-proxy config map with the value of
	// the server: from the passed in kubeconfig and subsequently restarts all
	// kube-proxy pods in the kube-system namespace. This change needs to be done
	// after a endpoint change is performed.
	PatchKubeProxyConfigMap(context.Context, *PatchKubeProxyConfigMapRequest) (*PatchKubeProxyConfigMapResponse, error)
	// CiliumRolloutRestart performs a rollout restart of the cilium daemonset.
	CiliumRolloutRestart(context.Context, *CiliumRolloutRestartRequest) (*CiliumRolloutRestartResponse, error)
	mustEmbedUnimplementedKuberServiceServer()
}

// UnimplementedKuberServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKuberServiceServer struct{}

func (UnimplementedKuberServiceServer) RemoveLBScrapeConfig(context.Context, *RemoveLBScrapeConfigRequest) (*RemoveLBScrapeConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLBScrapeConfig not implemented")
}
func (UnimplementedKuberServiceServer) StoreLBScrapeConfig(context.Context, *StoreLBScrapeConfigRequest) (*StoreLBScrapeConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreLBScrapeConfig not implemented")
}
func (UnimplementedKuberServiceServer) StoreClusterMetadata(context.Context, *StoreClusterMetadataRequest) (*StoreClusterMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreClusterMetadata not implemented")
}
func (UnimplementedKuberServiceServer) DeleteClusterMetadata(context.Context, *DeleteClusterMetadataRequest) (*DeleteClusterMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClusterMetadata not implemented")
}
func (UnimplementedKuberServiceServer) SetUpStorage(context.Context, *SetUpStorageRequest) (*SetUpStorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUpStorage not implemented")
}
func (UnimplementedKuberServiceServer) StoreKubeconfig(context.Context, *StoreKubeconfigRequest) (*StoreKubeconfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreKubeconfig not implemented")
}
func (UnimplementedKuberServiceServer) DeleteKubeconfig(context.Context, *DeleteKubeconfigRequest) (*DeleteKubeconfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKubeconfig not implemented")
}
func (UnimplementedKuberServiceServer) DeleteNodes(context.Context, *DeleteNodesRequest) (*DeleteNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodes not implemented")
}
func (UnimplementedKuberServiceServer) PatchNodes(context.Context, *PatchNodesRequest) (*PatchNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchNodes not implemented")
}
func (UnimplementedKuberServiceServer) SetUpClusterAutoscaler(context.Context, *SetUpClusterAutoscalerRequest) (*SetUpClusterAutoscalerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUpClusterAutoscaler not implemented")
}
func (UnimplementedKuberServiceServer) DestroyClusterAutoscaler(context.Context, *DestroyClusterAutoscalerRequest) (*DestroyClusterAutoscalerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyClusterAutoscaler not implemented")
}
func (UnimplementedKuberServiceServer) PatchClusterInfoConfigMap(context.Context, *PatchClusterInfoConfigMapRequest) (*PatchClusterInfoConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchClusterInfoConfigMap not implemented")
}
func (UnimplementedKuberServiceServer) PatchKubeProxyConfigMap(context.Context, *PatchKubeProxyConfigMapRequest) (*PatchKubeProxyConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchKubeProxyConfigMap not implemented")
}
func (UnimplementedKuberServiceServer) CiliumRolloutRestart(context.Context, *CiliumRolloutRestartRequest) (*CiliumRolloutRestartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CiliumRolloutRestart not implemented")
}
func (UnimplementedKuberServiceServer) mustEmbedUnimplementedKuberServiceServer() {}
func (UnimplementedKuberServiceServer) testEmbeddedByValue()                      {}

// UnsafeKuberServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KuberServiceServer will
// result in compilation errors.
type UnsafeKuberServiceServer interface {
	mustEmbedUnimplementedKuberServiceServer()
}

func RegisterKuberServiceServer(s grpc.ServiceRegistrar, srv KuberServiceServer) {
	// If the following call pancis, it indicates UnimplementedKuberServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KuberService_ServiceDesc, srv)
}

func _KuberService_RemoveLBScrapeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLBScrapeConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).RemoveLBScrapeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_RemoveLBScrapeConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).RemoveLBScrapeConfig(ctx, req.(*RemoveLBScrapeConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_StoreLBScrapeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreLBScrapeConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).StoreLBScrapeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_StoreLBScrapeConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).StoreLBScrapeConfig(ctx, req.(*StoreLBScrapeConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_StoreClusterMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreClusterMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).StoreClusterMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_StoreClusterMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).StoreClusterMetadata(ctx, req.(*StoreClusterMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_DeleteClusterMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClusterMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).DeleteClusterMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_DeleteClusterMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).DeleteClusterMetadata(ctx, req.(*DeleteClusterMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_SetUpStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUpStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).SetUpStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_SetUpStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).SetUpStorage(ctx, req.(*SetUpStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_StoreKubeconfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreKubeconfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).StoreKubeconfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_StoreKubeconfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).StoreKubeconfig(ctx, req.(*StoreKubeconfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_DeleteKubeconfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKubeconfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).DeleteKubeconfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_DeleteKubeconfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).DeleteKubeconfig(ctx, req.(*DeleteKubeconfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_DeleteNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).DeleteNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_DeleteNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).DeleteNodes(ctx, req.(*DeleteNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_PatchNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).PatchNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_PatchNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).PatchNodes(ctx, req.(*PatchNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_SetUpClusterAutoscaler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUpClusterAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).SetUpClusterAutoscaler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_SetUpClusterAutoscaler_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).SetUpClusterAutoscaler(ctx, req.(*SetUpClusterAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_DestroyClusterAutoscaler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyClusterAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).DestroyClusterAutoscaler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_DestroyClusterAutoscaler_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).DestroyClusterAutoscaler(ctx, req.(*DestroyClusterAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_PatchClusterInfoConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchClusterInfoConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).PatchClusterInfoConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_PatchClusterInfoConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).PatchClusterInfoConfigMap(ctx, req.(*PatchClusterInfoConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_PatchKubeProxyConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchKubeProxyConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).PatchKubeProxyConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_PatchKubeProxyConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).PatchKubeProxyConfigMap(ctx, req.(*PatchKubeProxyConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KuberService_CiliumRolloutRestart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CiliumRolloutRestartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KuberServiceServer).CiliumRolloutRestart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KuberService_CiliumRolloutRestart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KuberServiceServer).CiliumRolloutRestart(ctx, req.(*CiliumRolloutRestartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KuberService_ServiceDesc is the grpc.ServiceDesc for KuberService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KuberService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "claudie.KuberService",
	HandlerType: (*KuberServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoveLBScrapeConfig",
			Handler:    _KuberService_RemoveLBScrapeConfig_Handler,
		},
		{
			MethodName: "StoreLBScrapeConfig",
			Handler:    _KuberService_StoreLBScrapeConfig_Handler,
		},
		{
			MethodName: "StoreClusterMetadata",
			Handler:    _KuberService_StoreClusterMetadata_Handler,
		},
		{
			MethodName: "DeleteClusterMetadata",
			Handler:    _KuberService_DeleteClusterMetadata_Handler,
		},
		{
			MethodName: "SetUpStorage",
			Handler:    _KuberService_SetUpStorage_Handler,
		},
		{
			MethodName: "StoreKubeconfig",
			Handler:    _KuberService_StoreKubeconfig_Handler,
		},
		{
			MethodName: "DeleteKubeconfig",
			Handler:    _KuberService_DeleteKubeconfig_Handler,
		},
		{
			MethodName: "DeleteNodes",
			Handler:    _KuberService_DeleteNodes_Handler,
		},
		{
			MethodName: "PatchNodes",
			Handler:    _KuberService_PatchNodes_Handler,
		},
		{
			MethodName: "SetUpClusterAutoscaler",
			Handler:    _KuberService_SetUpClusterAutoscaler_Handler,
		},
		{
			MethodName: "DestroyClusterAutoscaler",
			Handler:    _KuberService_DestroyClusterAutoscaler_Handler,
		},
		{
			MethodName: "PatchClusterInfoConfigMap",
			Handler:    _KuberService_PatchClusterInfoConfigMap_Handler,
		},
		{
			MethodName: "PatchKubeProxyConfigMap",
			Handler:    _KuberService_PatchKubeProxyConfigMap_Handler,
		},
		{
			MethodName: "CiliumRolloutRestart",
			Handler:    _KuberService_CiliumRolloutRestart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuber.proto",
}
