// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v5.29.5
// source: spec/manifest.proto

package spec

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ProxyOp int32

const (
	// None specifies that no change happened in the desired
	// state of the Proxy settings compared to the current.
	ProxyOp_NONE ProxyOp = 0
	// Modified indicates some change happened, either add,
	// delete, modified, replaced etc.
	ProxyOp_MODIFIED ProxyOp = 1
	// Off indicates that the Proxy envs should be turned off.
	ProxyOp_OFF ProxyOp = 2
)

// Enum value maps for ProxyOp.
var (
	ProxyOp_name = map[int32]string{
		0: "NONE",
		1: "MODIFIED",
		2: "OFF",
	}
	ProxyOp_value = map[string]int32{
		"NONE":     0,
		"MODIFIED": 1,
		"OFF":      2,
	}
)

func (x ProxyOp) Enum() *ProxyOp {
	p := new(ProxyOp)
	*p = x
	return p
}

func (x ProxyOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProxyOp) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[0].Descriptor()
}

func (ProxyOp) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[0]
}

func (x ProxyOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProxyOp.Descriptor instead.
func (ProxyOp) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{0}
}

// RoleType specifies the type of the role.
type RoleType int32

const (
	// API server load balancer.
	RoleType_ApiServer RoleType = 0
	// Ingress load balancer.
	RoleType_Ingress RoleType = 1
)

// Enum value maps for RoleType.
var (
	RoleType_name = map[int32]string{
		0: "ApiServer",
		1: "Ingress",
	}
	RoleType_value = map[string]int32{
		"ApiServer": 0,
		"Ingress":   1,
	}
)

func (x RoleType) Enum() *RoleType {
	p := new(RoleType)
	*p = x
	return p
}

func (x RoleType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RoleType) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[1].Descriptor()
}

func (RoleType) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[1]
}

func (x RoleType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RoleType.Descriptor instead.
func (RoleType) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{1}
}

// ClusterType specifies the type of the cluster.
type ClusterType int32

const (
	// Kubernetes cluster.
	ClusterType_K8s ClusterType = 0
	// Load balancer cluster.
	ClusterType_LB ClusterType = 1
)

// Enum value maps for ClusterType.
var (
	ClusterType_name = map[int32]string{
		0: "K8s",
		1: "LB",
	}
	ClusterType_value = map[string]int32{
		"K8s": 0,
		"LB":  1,
	}
)

func (x ClusterType) Enum() *ClusterType {
	p := new(ClusterType)
	*p = x
	return p
}

func (x ClusterType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterType) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[2].Descriptor()
}

func (ClusterType) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[2]
}

func (x ClusterType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterType.Descriptor instead.
func (ClusterType) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{2}
}

type Event int32

const (
	Event_UNKNOWN Event = 0
	Event_CREATE  Event = 1
	Event_UPDATE  Event = 2
	Event_DELETE  Event = 3
)

// Enum value maps for Event.
var (
	Event_name = map[int32]string{
		0: "UNKNOWN",
		1: "CREATE",
		2: "UPDATE",
		3: "DELETE",
	}
	Event_value = map[string]int32{
		"UNKNOWN": 0,
		"CREATE":  1,
		"UPDATE":  2,
		"DELETE":  3,
	}
)

func (x Event) Enum() *Event {
	p := new(Event)
	*p = x
	return p
}

func (x Event) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Event) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[3].Descriptor()
}

func (Event) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[3]
}

func (x Event) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Event.Descriptor instead.
func (Event) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{3}
}

type ApiEndpointChangeState int32

const (
	// NoChange represents the 1st case - no change is needed as the LB cluster is currently
	// attached and the desired spec contains no changes.
	ApiEndpointChangeState_NoChange ApiEndpointChangeState = 0
	// AttachingLoadBalancer represents 2nd case - the K8s cluster previously
	// didn't have an LB cluster attached and the ports needed to communicate with the API server
	// were exposed. After attaching an LB cluster to the existing K8s cluster the ports
	// were closed and are no longer accessible, and thus we need to change the API endpoint.
	ApiEndpointChangeState_AttachingLoadBalancer ApiEndpointChangeState = 1
	// DetachingLoadBalancer represents 3rd. case - the K8s cluster had an existing
	// LB cluster attached but the new state removed the LB cluster and thus the API endpoint
	// needs to be changed back to one of the control nodes of the cluster.
	ApiEndpointChangeState_DetachingLoadBalancer ApiEndpointChangeState = 2
	// EndpointRenamed represents the 4th. case - the K8s cluster has an existing
	// LB cluster attached and also keeps it but the endpoint has changed in the desired state.
	ApiEndpointChangeState_EndpointRenamed ApiEndpointChangeState = 3
	// MoveEndpoint represents the 5th. case - the K8s cluster has an existing
	// LB cluster attached, but it will be switched to a different LB cluster
	// in the desired state.
	ApiEndpointChangeState_MoveEndpoint ApiEndpointChangeState = 4
)

// Enum value maps for ApiEndpointChangeState.
var (
	ApiEndpointChangeState_name = map[int32]string{
		0: "NoChange",
		1: "AttachingLoadBalancer",
		2: "DetachingLoadBalancer",
		3: "EndpointRenamed",
		4: "MoveEndpoint",
	}
	ApiEndpointChangeState_value = map[string]int32{
		"NoChange":              0,
		"AttachingLoadBalancer": 1,
		"DetachingLoadBalancer": 2,
		"EndpointRenamed":       3,
		"MoveEndpoint":          4,
	}
)

func (x ApiEndpointChangeState) Enum() *ApiEndpointChangeState {
	p := new(ApiEndpointChangeState)
	*p = x
	return p
}

func (x ApiEndpointChangeState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ApiEndpointChangeState) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[4].Descriptor()
}

func (ApiEndpointChangeState) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[4]
}

func (x ApiEndpointChangeState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ApiEndpointChangeState.Descriptor instead.
func (ApiEndpointChangeState) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{4}
}

type Manifest_State int32

const (
	Manifest_Pending   Manifest_State = 0
	Manifest_Scheduled Manifest_State = 1
	Manifest_Done      Manifest_State = 2
	Manifest_Error     Manifest_State = 3
)

// Enum value maps for Manifest_State.
var (
	Manifest_State_name = map[int32]string{
		0: "Pending",
		1: "Scheduled",
		2: "Done",
		3: "Error",
	}
	Manifest_State_value = map[string]int32{
		"Pending":   0,
		"Scheduled": 1,
		"Done":      2,
		"Error":     3,
	}
)

func (x Manifest_State) Enum() *Manifest_State {
	p := new(Manifest_State)
	*p = x
	return p
}

func (x Manifest_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Manifest_State) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[5].Descriptor()
}

func (Manifest_State) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[5]
}

func (x Manifest_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Manifest_State.Descriptor instead.
func (Manifest_State) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{1, 0}
}

type Workflow_Stage int32

const (
	// NONE indicates that no stage is currently executing.
	Workflow_NONE Workflow_Stage = 0
	// TERRAFORMER indicates that the cluster is currently being build in
	// terraformer.
	Workflow_TERRAFORMER Workflow_Stage = 1
	// ANSIBLER indicates that the cluster is currently being build in ansibler.
	Workflow_ANSIBLER Workflow_Stage = 2
	// KUBE_ELEVEN indicates that the cluster is currently being build in kube
	// eleven.
	Workflow_KUBE_ELEVEN Workflow_Stage = 3
	// KUBER indicates that the cluster is currently being build in kuber.
	Workflow_KUBER Workflow_Stage = 4
	// DESTROY_TERRAFORMER indicates that infra for a cluster is being deleted.
	Workflow_DESTROY_TERRAFORMER Workflow_Stage = 7
	// DESTROY_KUBER indicates that data for a cluster is being deleted.
	Workflow_DESTROY_KUBER Workflow_Stage = 8
	// DELETE_NODES indicates the nodes are being deleted for the cluster.
	Workflow_DELETE_NODES Workflow_Stage = 9
)

// Enum value maps for Workflow_Stage.
var (
	Workflow_Stage_name = map[int32]string{
		0: "NONE",
		1: "TERRAFORMER",
		2: "ANSIBLER",
		3: "KUBE_ELEVEN",
		4: "KUBER",
		7: "DESTROY_TERRAFORMER",
		8: "DESTROY_KUBER",
		9: "DELETE_NODES",
	}
	Workflow_Stage_value = map[string]int32{
		"NONE":                0,
		"TERRAFORMER":         1,
		"ANSIBLER":            2,
		"KUBE_ELEVEN":         3,
		"KUBER":               4,
		"DESTROY_TERRAFORMER": 7,
		"DESTROY_KUBER":       8,
		"DELETE_NODES":        9,
	}
)

func (x Workflow_Stage) Enum() *Workflow_Stage {
	p := new(Workflow_Stage)
	*p = x
	return p
}

func (x Workflow_Stage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Workflow_Stage) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[6].Descriptor()
}

func (Workflow_Stage) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[6]
}

func (x Workflow_Stage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Workflow_Stage.Descriptor instead.
func (Workflow_Stage) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{6, 0}
}

type Workflow_Status int32

const (
	// DONE indicates that the workflow has finished.
	Workflow_DONE Workflow_Status = 0
	// ERROR indicates that an error occurred while building the cluster.
	Workflow_ERROR Workflow_Status = 1
	// IN_PROGRESS indicates that the cluster is currently being build.
	Workflow_IN_PROGRESS Workflow_Status = 2
)

// Enum value maps for Workflow_Status.
var (
	Workflow_Status_name = map[int32]string{
		0: "DONE",
		1: "ERROR",
		2: "IN_PROGRESS",
	}
	Workflow_Status_value = map[string]int32{
		"DONE":        0,
		"ERROR":       1,
		"IN_PROGRESS": 2,
	}
)

func (x Workflow_Status) Enum() *Workflow_Status {
	p := new(Workflow_Status)
	*p = x
	return p
}

func (x Workflow_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Workflow_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[7].Descriptor()
}

func (Workflow_Status) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[7]
}

func (x Workflow_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Workflow_Status.Descriptor instead.
func (Workflow_Status) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{6, 1}
}

type Retry_Repeat_Kind int32

const (
	Retry_Repeat_ENDLESS     Retry_Repeat_Kind = 0
	Retry_Repeat_EXPONENTIAL Retry_Repeat_Kind = 1
)

// Enum value maps for Retry_Repeat_Kind.
var (
	Retry_Repeat_Kind_name = map[int32]string{
		0: "ENDLESS",
		1: "EXPONENTIAL",
	}
	Retry_Repeat_Kind_value = map[string]int32{
		"ENDLESS":     0,
		"EXPONENTIAL": 1,
	}
)

func (x Retry_Repeat_Kind) Enum() *Retry_Repeat_Kind {
	p := new(Retry_Repeat_Kind)
	*p = x
	return p
}

func (x Retry_Repeat_Kind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Retry_Repeat_Kind) Descriptor() protoreflect.EnumDescriptor {
	return file_spec_manifest_proto_enumTypes[8].Descriptor()
}

func (Retry_Repeat_Kind) Type() protoreflect.EnumType {
	return &file_spec_manifest_proto_enumTypes[8]
}

func (x Retry_Repeat_Kind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Retry_Repeat_Kind.Descriptor instead.
func (Retry_Repeat_Kind) EnumDescriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{15, 0, 0}
}

// Config holds data for a single manifest.
type Config struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// version of the config.
	Version uint64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Config name - same as input manifest name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Information related within a k8s context.
	K8SCtx *KubernetesContext `protobuf:"bytes,3,opt,name=k8sCtx,proto3" json:"k8sCtx,omitempty"`
	// Client defined manifest.
	Manifest *Manifest `protobuf:"bytes,4,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Clusters parsed from the supplied manifest.
	Clusters      map[string]*ClusterState `protobuf:"bytes,5,rep,name=clusters,proto3" json:"clusters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config) Reset() {
	*x = Config{}
	mi := &file_spec_manifest_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{0}
}

func (x *Config) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Config) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Config) GetK8SCtx() *KubernetesContext {
	if x != nil {
		return x.K8SCtx
	}
	return nil
}

func (x *Config) GetManifest() *Manifest {
	if x != nil {
		return x.Manifest
	}
	return nil
}

func (x *Config) GetClusters() map[string]*ClusterState {
	if x != nil {
		return x.Clusters
	}
	return nil
}

type Manifest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Raw                 string                 `protobuf:"bytes,1,opt,name=raw,proto3" json:"raw,omitempty"`
	Checksum            []byte                 `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	LastAppliedChecksum []byte                 `protobuf:"bytes,3,opt,name=lastAppliedChecksum,proto3" json:"lastAppliedChecksum,omitempty"`
	State               Manifest_State         `protobuf:"varint,4,opt,name=state,proto3,enum=spec.Manifest_State" json:"state,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Manifest) Reset() {
	*x = Manifest{}
	mi := &file_spec_manifest_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Manifest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Manifest) ProtoMessage() {}

func (x *Manifest) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Manifest.ProtoReflect.Descriptor instead.
func (*Manifest) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{1}
}

func (x *Manifest) GetRaw() string {
	if x != nil {
		return x.Raw
	}
	return ""
}

func (x *Manifest) GetChecksum() []byte {
	if x != nil {
		return x.Checksum
	}
	return nil
}

func (x *Manifest) GetLastAppliedChecksum() []byte {
	if x != nil {
		return x.LastAppliedChecksum
	}
	return nil
}

func (x *Manifest) GetState() Manifest_State {
	if x != nil {
		return x.State
	}
	return Manifest_Pending
}

type ClusterState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Current       *Clusters              `protobuf:"bytes,1,opt,name=current,proto3" json:"current,omitempty"`
	Desired       *Clusters              `protobuf:"bytes,2,opt,name=desired,proto3" json:"desired,omitempty"`
	Events        *Events                `protobuf:"bytes,3,opt,name=events,proto3" json:"events,omitempty"`
	State         *Workflow              `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterState) Reset() {
	*x = ClusterState{}
	mi := &file_spec_manifest_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterState) ProtoMessage() {}

func (x *ClusterState) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterState.ProtoReflect.Descriptor instead.
func (*ClusterState) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{2}
}

func (x *ClusterState) GetCurrent() *Clusters {
	if x != nil {
		return x.Current
	}
	return nil
}

func (x *ClusterState) GetDesired() *Clusters {
	if x != nil {
		return x.Desired
	}
	return nil
}

func (x *ClusterState) GetEvents() *Events {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *ClusterState) GetState() *Workflow {
	if x != nil {
		return x.State
	}
	return nil
}

type Clusters struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	K8S           *K8Scluster            `protobuf:"bytes,1,opt,name=k8s,proto3" json:"k8s,omitempty"`
	LoadBalancers *LoadBalancers         `protobuf:"bytes,2,opt,name=loadBalancers,proto3" json:"loadBalancers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Clusters) Reset() {
	*x = Clusters{}
	mi := &file_spec_manifest_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Clusters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Clusters) ProtoMessage() {}

func (x *Clusters) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Clusters.ProtoReflect.Descriptor instead.
func (*Clusters) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{3}
}

func (x *Clusters) GetK8S() *K8Scluster {
	if x != nil {
		return x.K8S
	}
	return nil
}

func (x *Clusters) GetLoadBalancers() *LoadBalancers {
	if x != nil {
		return x.LoadBalancers
	}
	return nil
}

type LoadBalancers struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Clusters      []*LBcluster           `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoadBalancers) Reset() {
	*x = LoadBalancers{}
	mi := &file_spec_manifest_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancers) ProtoMessage() {}

func (x *LoadBalancers) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadBalancers.ProtoReflect.Descriptor instead.
func (*LoadBalancers) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{4}
}

func (x *LoadBalancers) GetClusters() []*LBcluster {
	if x != nil {
		return x.Clusters
	}
	return nil
}

type KubernetesContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name represents the input manifest resource name in Kubernetes
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace represents the input manifest resource namespace in Kubernetes
	Namespace     string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesContext) Reset() {
	*x = KubernetesContext{}
	mi := &file_spec_manifest_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesContext) ProtoMessage() {}

func (x *KubernetesContext) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesContext.ProtoReflect.Descriptor instead.
func (*KubernetesContext) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{5}
}

func (x *KubernetesContext) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesContext) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

type Workflow struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Stage  Workflow_Stage         `protobuf:"varint,1,opt,name=stage,proto3,enum=spec.Workflow_Stage" json:"stage,omitempty"`
	Status Workflow_Status        `protobuf:"varint,2,opt,name=status,proto3,enum=spec.Workflow_Status" json:"status,omitempty"`
	// additional information describing the state and status.
	Description   string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Workflow) Reset() {
	*x = Workflow{}
	mi := &file_spec_manifest_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Workflow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Workflow) ProtoMessage() {}

func (x *Workflow) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Workflow.ProtoReflect.Descriptor instead.
func (*Workflow) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{6}
}

func (x *Workflow) GetStage() Workflow_Stage {
	if x != nil {
		return x.Stage
	}
	return Workflow_NONE
}

func (x *Workflow) GetStatus() Workflow_Status {
	if x != nil {
		return x.Status
	}
	return Workflow_DONE
}

func (x *Workflow) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// K8scluster represents a single kubernetes cluster specified in the manifest.
type K8Scluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// General info about the cluster.
	ClusterInfo *ClusterInfo `protobuf:"bytes,1,opt,name=clusterInfo,proto3" json:"clusterInfo,omitempty"`
	// Network range for the VPN.
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	// Kubeconfig of the cluster.
	Kubeconfig string `protobuf:"bytes,3,opt,name=kubeconfig,proto3" json:"kubeconfig,omitempty"`
	// Kubernetes version.
	Kubernetes string `protobuf:"bytes,4,opt,name=kubernetes,proto3" json:"kubernetes,omitempty"`
	// General information about a proxy used to build a K8s cluster.
	InstallationProxy *InstallationProxy `protobuf:"bytes,5,opt,name=installationProxy,proto3" json:"installationProxy,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *K8Scluster) Reset() {
	*x = K8Scluster{}
	mi := &file_spec_manifest_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *K8Scluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*K8Scluster) ProtoMessage() {}

func (x *K8Scluster) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use K8Scluster.ProtoReflect.Descriptor instead.
func (*K8Scluster) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{7}
}

func (x *K8Scluster) GetClusterInfo() *ClusterInfo {
	if x != nil {
		return x.ClusterInfo
	}
	return nil
}

func (x *K8Scluster) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *K8Scluster) GetKubeconfig() string {
	if x != nil {
		return x.Kubeconfig
	}
	return ""
}

func (x *K8Scluster) GetKubernetes() string {
	if x != nil {
		return x.Kubernetes
	}
	return ""
}

func (x *K8Scluster) GetInstallationProxy() *InstallationProxy {
	if x != nil {
		return x.InstallationProxy
	}
	return nil
}

// LBcluster represents a single load balancer cluster specified in the
// manifest.
type LBcluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// General info about the cluster.
	ClusterInfo *ClusterInfo `protobuf:"bytes,1,opt,name=clusterInfo,proto3" json:"clusterInfo,omitempty"`
	// Array of Load balancer roles.
	Roles []*Role `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	// DNS information.
	Dns *DNS `protobuf:"bytes,3,opt,name=dns,proto3" json:"dns,omitempty"`
	// Kubernetes cluster name of the cluster this load balancer is attached to.
	TargetedK8S string `protobuf:"bytes,4,opt,name=targetedK8s,proto3" json:"targetedK8s,omitempty"`
	// usedApiEndpoint signals which LB is actually used as the api endpoint.
	// Claudie manifest validation does not allow for multiple API endpoints
	// to be present, however. Internally claudie can deal with more loadbalancers
	// that have the API role, this is due to the creation of intermediate representation
	// which always add new infrastructure before making any further changes.
	// To recognize which of them is actually used this field was added.
	UsedApiEndpoint bool `protobuf:"varint,5,opt,name=usedApiEndpoint,proto3" json:"usedApiEndpoint,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LBcluster) Reset() {
	*x = LBcluster{}
	mi := &file_spec_manifest_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LBcluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LBcluster) ProtoMessage() {}

func (x *LBcluster) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LBcluster.ProtoReflect.Descriptor instead.
func (*LBcluster) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{8}
}

func (x *LBcluster) GetClusterInfo() *ClusterInfo {
	if x != nil {
		return x.ClusterInfo
	}
	return nil
}

func (x *LBcluster) GetRoles() []*Role {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *LBcluster) GetDns() *DNS {
	if x != nil {
		return x.Dns
	}
	return nil
}

func (x *LBcluster) GetTargetedK8S() string {
	if x != nil {
		return x.TargetedK8S
	}
	return ""
}

func (x *LBcluster) GetUsedApiEndpoint() bool {
	if x != nil {
		return x.UsedApiEndpoint
	}
	return false
}

// ClusterInfo holds general information about the clusters.
type ClusterInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the cluster.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Random hash of the cluster.
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// Array of node pools this cluster is made of.
	NodePools     []*NodePool `protobuf:"bytes,5,rep,name=nodePools,proto3" json:"nodePools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterInfo) Reset() {
	*x = ClusterInfo{}
	mi := &file_spec_manifest_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterInfo) ProtoMessage() {}

func (x *ClusterInfo) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterInfo.ProtoReflect.Descriptor instead.
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{9}
}

func (x *ClusterInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ClusterInfo) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

func (x *ClusterInfo) GetNodePools() []*NodePool {
	if x != nil {
		return x.NodePools
	}
	return nil
}

// InstallationProxy holds general information about a proxy used to build a K8s cluster.
type InstallationProxy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Proxy installation mode.
	Mode string `protobuf:"bytes,1,opt,name=mode,proto3" json:"mode,omitempty"`
	// Proxy endpoint used to access the proxy.
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// NoProxy is a comma-separated list of values that will be added to the default list of NoProxies used by Claudie.
	//
	// The default no proxy list is: 127.0.0.1/8,localhost,cluster.local,10.244.0.0/16,10.96.0.0/12"
	// Any values specified will be appended to the end of the default NoProxy list.
	// This field only has an effect if the Proxy is turned on.
	NoProxy       string `protobuf:"bytes,3,opt,name=noProxy,proto3" json:"noProxy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallationProxy) Reset() {
	*x = InstallationProxy{}
	mi := &file_spec_manifest_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallationProxy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallationProxy) ProtoMessage() {}

func (x *InstallationProxy) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallationProxy.ProtoReflect.Descriptor instead.
func (*InstallationProxy) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{10}
}

func (x *InstallationProxy) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

func (x *InstallationProxy) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *InstallationProxy) GetNoProxy() string {
	if x != nil {
		return x.NoProxy
	}
	return ""
}

// ProxyEnvs holds information about a need to update proxy envs, proxy endpoint, and no proxy list.
type ProxyEnvs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signal a need to update proxy envs
	Op ProxyOp `protobuf:"varint,1,opt,name=op,proto3,enum=spec.ProxyOp" json:"op,omitempty"`
	// Holds a proxy endpoint.
	HttpProxyUrl string `protobuf:"bytes,2,opt,name=httpProxyUrl,proto3" json:"httpProxyUrl,omitempty"`
	// Holds a list of IPs and hostnames that aren't routed through proxy.
	NoProxyList   string `protobuf:"bytes,3,opt,name=noProxyList,proto3" json:"noProxyList,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyEnvs) Reset() {
	*x = ProxyEnvs{}
	mi := &file_spec_manifest_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyEnvs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyEnvs) ProtoMessage() {}

func (x *ProxyEnvs) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyEnvs.ProtoReflect.Descriptor instead.
func (*ProxyEnvs) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{11}
}

func (x *ProxyEnvs) GetOp() ProxyOp {
	if x != nil {
		return x.Op
	}
	return ProxyOp_NONE
}

func (x *ProxyEnvs) GetHttpProxyUrl() string {
	if x != nil {
		return x.HttpProxyUrl
	}
	return ""
}

func (x *ProxyEnvs) GetNoProxyList() string {
	if x != nil {
		return x.NoProxyList
	}
	return ""
}

// Role represents a single loadbalancer role from the manifest.
type Role struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the role.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Protocol that load balancer uses to forward traffic. ["tcp", "udp"]
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Port that load balancer will forward from.
	Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// Port that load balancer will forward to.
	TargetPort int32 `protobuf:"varint,4,opt,name=targetPort,proto3" json:"targetPort,omitempty"`
	// Targeted nodes in Kubernetes clusters.
	TargetPools []string `protobuf:"bytes,7,rep,name=targetPools,proto3" json:"targetPools,omitempty"`
	// Type of the role.
	RoleType RoleType `protobuf:"varint,6,opt,name=roleType,proto3,enum=spec.RoleType" json:"roleType,omitempty"`
	// Additional settings for the role.
	Settings      *Role_Settings `protobuf:"bytes,8,opt,name=settings,proto3" json:"settings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Role) Reset() {
	*x = Role{}
	mi := &file_spec_manifest_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Role) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Role) ProtoMessage() {}

func (x *Role) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Role.ProtoReflect.Descriptor instead.
func (*Role) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{12}
}

func (x *Role) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Role) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *Role) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *Role) GetTargetPort() int32 {
	if x != nil {
		return x.TargetPort
	}
	return 0
}

func (x *Role) GetTargetPools() []string {
	if x != nil {
		return x.TargetPools
	}
	return nil
}

func (x *Role) GetRoleType() RoleType {
	if x != nil {
		return x.RoleType
	}
	return RoleType_ApiServer
}

func (x *Role) GetSettings() *Role_Settings {
	if x != nil {
		return x.Settings
	}
	return nil
}

type Events struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Events        []*TaskEvent           `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	Ttl           int32                  `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Autoscaled    bool                   `protobuf:"varint,3,opt,name=autoscaled,proto3" json:"autoscaled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Events) Reset() {
	*x = Events{}
	mi := &file_spec_manifest_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Events) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Events) ProtoMessage() {}

func (x *Events) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Events.ProtoReflect.Descriptor instead.
func (*Events) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{13}
}

func (x *Events) GetEvents() []*TaskEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *Events) GetTtl() int32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *Events) GetAutoscaled() bool {
	if x != nil {
		return x.Autoscaled
	}
	return false
}

type TaskEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Event         Event                  `protobuf:"varint,3,opt,name=event,proto3,enum=spec.Event" json:"event,omitempty"`
	Task          *Task                  `protobuf:"bytes,4,opt,name=task,proto3" json:"task,omitempty"`
	Description   string                 `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	OnError       *Retry                 `protobuf:"bytes,7,opt,name=onError,proto3" json:"onError,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskEvent) Reset() {
	*x = TaskEvent{}
	mi := &file_spec_manifest_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskEvent) ProtoMessage() {}

func (x *TaskEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskEvent.ProtoReflect.Descriptor instead.
func (*TaskEvent) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{14}
}

func (x *TaskEvent) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TaskEvent) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *TaskEvent) GetEvent() Event {
	if x != nil {
		return x.Event
	}
	return Event_UNKNOWN
}

func (x *TaskEvent) GetTask() *Task {
	if x != nil {
		return x.Task
	}
	return nil
}

func (x *TaskEvent) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *TaskEvent) GetOnError() *Retry {
	if x != nil {
		return x.OnError
	}
	return nil
}

type Retry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Do:
	//
	//	*Retry_Repeat_
	//	*Retry_Rollback_
	Do            isRetry_Do `protobuf_oneof:"Do"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Retry) Reset() {
	*x = Retry{}
	mi := &file_spec_manifest_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Retry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Retry) ProtoMessage() {}

func (x *Retry) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Retry.ProtoReflect.Descriptor instead.
func (*Retry) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{15}
}

func (x *Retry) GetDo() isRetry_Do {
	if x != nil {
		return x.Do
	}
	return nil
}

func (x *Retry) GetRepeat() *Retry_Repeat {
	if x != nil {
		if x, ok := x.Do.(*Retry_Repeat_); ok {
			return x.Repeat
		}
	}
	return nil
}

func (x *Retry) GetRollback() *Retry_Rollback {
	if x != nil {
		if x, ok := x.Do.(*Retry_Rollback_); ok {
			return x.Rollback
		}
	}
	return nil
}

type isRetry_Do interface {
	isRetry_Do()
}

type Retry_Repeat_ struct {
	Repeat *Retry_Repeat `protobuf:"bytes,3,opt,name=repeat,proto3,oneof"`
}

type Retry_Rollback_ struct {
	Rollback *Retry_Rollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof"`
}

func (*Retry_Repeat_) isRetry_Do() {}

func (*Retry_Rollback_) isRetry_Do() {}

type Task struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CreateState   *CreateState           `protobuf:"bytes,1,opt,name=createState,proto3" json:"createState,omitempty"`
	UpdateState   *UpdateState           `protobuf:"bytes,2,opt,name=updateState,proto3" json:"updateState,omitempty"`
	DeleteState   *DeleteState           `protobuf:"bytes,3,opt,name=deleteState,proto3" json:"deleteState,omitempty"`
	Options       uint64                 `protobuf:"varint,4,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Task) Reset() {
	*x = Task{}
	mi := &file_spec_manifest_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Task) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Task) ProtoMessage() {}

func (x *Task) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Task.ProtoReflect.Descriptor instead.
func (*Task) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{16}
}

func (x *Task) GetCreateState() *CreateState {
	if x != nil {
		return x.CreateState
	}
	return nil
}

func (x *Task) GetUpdateState() *UpdateState {
	if x != nil {
		return x.UpdateState
	}
	return nil
}

func (x *Task) GetDeleteState() *DeleteState {
	if x != nil {
		return x.DeleteState
	}
	return nil
}

func (x *Task) GetOptions() uint64 {
	if x != nil {
		return x.Options
	}
	return 0
}

type CreateState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	K8S           *K8Scluster            `protobuf:"bytes,1,opt,name=k8s,proto3" json:"k8s,omitempty"`
	Lbs           *LoadBalancers         `protobuf:"bytes,2,opt,name=lbs,proto3" json:"lbs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateState) Reset() {
	*x = CreateState{}
	mi := &file_spec_manifest_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateState) ProtoMessage() {}

func (x *CreateState) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateState.ProtoReflect.Descriptor instead.
func (*CreateState) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{17}
}

func (x *CreateState) GetK8S() *K8Scluster {
	if x != nil {
		return x.K8S
	}
	return nil
}

func (x *CreateState) GetLbs() *LoadBalancers {
	if x != nil {
		return x.Lbs
	}
	return nil
}

type UpdateState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	K8S   *K8Scluster            `protobuf:"bytes,1,opt,name=k8s,proto3" json:"k8s,omitempty"`
	Lbs   *LoadBalancers         `protobuf:"bytes,2,opt,name=lbs,proto3" json:"lbs,omitempty"`
	// Types that are valid to be assigned to EndpointChange:
	//
	//	*UpdateState_NewControlEndpoint
	//	*UpdateState_LbEndpointChange
	EndpointChange isUpdateState_EndpointChange `protobuf_oneof:"EndpointChange"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *UpdateState) Reset() {
	*x = UpdateState{}
	mi := &file_spec_manifest_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateState) ProtoMessage() {}

func (x *UpdateState) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateState.ProtoReflect.Descriptor instead.
func (*UpdateState) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{18}
}

func (x *UpdateState) GetK8S() *K8Scluster {
	if x != nil {
		return x.K8S
	}
	return nil
}

func (x *UpdateState) GetLbs() *LoadBalancers {
	if x != nil {
		return x.Lbs
	}
	return nil
}

func (x *UpdateState) GetEndpointChange() isUpdateState_EndpointChange {
	if x != nil {
		return x.EndpointChange
	}
	return nil
}

func (x *UpdateState) GetNewControlEndpoint() *UpdateState_K8SEndpoint {
	if x != nil {
		if x, ok := x.EndpointChange.(*UpdateState_NewControlEndpoint); ok {
			return x.NewControlEndpoint
		}
	}
	return nil
}

func (x *UpdateState) GetLbEndpointChange() *UpdateState_LbEndpoint {
	if x != nil {
		if x, ok := x.EndpointChange.(*UpdateState_LbEndpointChange); ok {
			return x.LbEndpointChange
		}
	}
	return nil
}

type isUpdateState_EndpointChange interface {
	isUpdateState_EndpointChange()
}

type UpdateState_NewControlEndpoint struct {
	NewControlEndpoint *UpdateState_K8SEndpoint `protobuf:"bytes,3,opt,name=newControlEndpoint,proto3,oneof"`
}

type UpdateState_LbEndpointChange struct {
	LbEndpointChange *UpdateState_LbEndpoint `protobuf:"bytes,4,opt,name=lbEndpointChange,proto3,oneof"`
}

func (*UpdateState_NewControlEndpoint) isUpdateState_EndpointChange() {}

func (*UpdateState_LbEndpointChange) isUpdateState_EndpointChange() {}

type DeleteState struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	K8S           *DeleteState_K8S            `protobuf:"bytes,1,opt,name=k8s,proto3" json:"k8s,omitempty"`
	Lbs           []*DeleteState_LoadBalancer `protobuf:"bytes,2,rep,name=lbs,proto3" json:"lbs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteState) Reset() {
	*x = DeleteState{}
	mi := &file_spec_manifest_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteState) ProtoMessage() {}

func (x *DeleteState) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteState.ProtoReflect.Descriptor instead.
func (*DeleteState) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{19}
}

func (x *DeleteState) GetK8S() *DeleteState_K8S {
	if x != nil {
		return x.K8S
	}
	return nil
}

func (x *DeleteState) GetLbs() []*DeleteState_LoadBalancer {
	if x != nil {
		return x.Lbs
	}
	return nil
}

type DeletedNodes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nodes specifies which nodes should be deleted
	// from the nodepool.
	Nodes []string `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// keepNodePoolIfEmpty specifies if the nodepool should
	// be deleted from the current state if its node count
	// reaches zero. Currently this will only be used with
	// autoscaled dynamic nodepools which can have a minimum
	// of 0 nodes, other nodepool types will have this always
	// set to false to indicate that after deletion of all nodes
	// the nodepool should no longer be tracked in the current state.
	KeepNodePoolIfEmpty bool `protobuf:"varint,2,opt,name=keepNodePoolIfEmpty,proto3" json:"keepNodePoolIfEmpty,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DeletedNodes) Reset() {
	*x = DeletedNodes{}
	mi := &file_spec_manifest_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeletedNodes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeletedNodes) ProtoMessage() {}

func (x *DeletedNodes) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeletedNodes.ProtoReflect.Descriptor instead.
func (*DeletedNodes) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{20}
}

func (x *DeletedNodes) GetNodes() []string {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *DeletedNodes) GetKeepNodePoolIfEmpty() bool {
	if x != nil {
		return x.KeepNodePoolIfEmpty
	}
	return false
}

type Role_Settings struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ProxyProtocol  bool                   `protobuf:"varint,1,opt,name=proxyProtocol,proto3" json:"proxyProtocol,omitempty"`
	StickySessions bool                   `protobuf:"varint,2,opt,name=stickySessions,proto3" json:"stickySessions,omitempty"`
	// required port for the envoy admin interface,
	// on change will issue restart of the envoy proxy.
	EnvoyAdminPort int32 `protobuf:"varint,3,opt,name=envoy_admin_port,json=envoyAdminPort,proto3" json:"envoy_admin_port,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Role_Settings) Reset() {
	*x = Role_Settings{}
	mi := &file_spec_manifest_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Role_Settings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Role_Settings) ProtoMessage() {}

func (x *Role_Settings) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Role_Settings.ProtoReflect.Descriptor instead.
func (*Role_Settings) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{12, 0}
}

func (x *Role_Settings) GetProxyProtocol() bool {
	if x != nil {
		return x.ProxyProtocol
	}
	return false
}

func (x *Role_Settings) GetStickySessions() bool {
	if x != nil {
		return x.StickySessions
	}
	return false
}

func (x *Role_Settings) GetEnvoyAdminPort() int32 {
	if x != nil {
		return x.EnvoyAdminPort
	}
	return 0
}

type Retry_Repeat struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  Retry_Repeat_Kind      `protobuf:"varint,1,opt,name=kind,proto3,enum=spec.Retry_Repeat_Kind" json:"kind,omitempty"`
	// currentTick specifies the current number of ticks.
	// A tick is an regular interval at which manifests are being checked.
	// to check the Tick timeout see: manager/internal/service/watchers.go
	CurrentTick uint32 `protobuf:"varint,2,opt,name=currentTick,proto3" json:"currentTick,omitempty"`
	// stopAfter specifies the maximum number of ticks, after reaching this value the manifest will be rescheduled
	// for the last time before giving up.
	StopAfter uint32 `protobuf:"varint,3,opt,name=stopAfter,proto3" json:"stopAfter,omitempty"`
	// retryAfter specifies the number of ticks to wait before rescheduling the manifest again.
	// this value will be set to the value of currentTick after it is updated.
	RetryAfter    uint32 `protobuf:"varint,4,opt,name=retryAfter,proto3" json:"retryAfter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Retry_Repeat) Reset() {
	*x = Retry_Repeat{}
	mi := &file_spec_manifest_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Retry_Repeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Retry_Repeat) ProtoMessage() {}

func (x *Retry_Repeat) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Retry_Repeat.ProtoReflect.Descriptor instead.
func (*Retry_Repeat) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{15, 0}
}

func (x *Retry_Repeat) GetKind() Retry_Repeat_Kind {
	if x != nil {
		return x.Kind
	}
	return Retry_Repeat_ENDLESS
}

func (x *Retry_Repeat) GetCurrentTick() uint32 {
	if x != nil {
		return x.CurrentTick
	}
	return 0
}

func (x *Retry_Repeat) GetStopAfter() uint32 {
	if x != nil {
		return x.StopAfter
	}
	return 0
}

func (x *Retry_Repeat) GetRetryAfter() uint32 {
	if x != nil {
		return x.RetryAfter
	}
	return 0
}

type Retry_Rollback struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tasks         []*TaskEvent           `protobuf:"bytes,1,rep,name=tasks,proto3" json:"tasks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Retry_Rollback) Reset() {
	*x = Retry_Rollback{}
	mi := &file_spec_manifest_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Retry_Rollback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Retry_Rollback) ProtoMessage() {}

func (x *Retry_Rollback) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Retry_Rollback.ProtoReflect.Descriptor instead.
func (*Retry_Rollback) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{15, 1}
}

func (x *Retry_Rollback) GetTasks() []*TaskEvent {
	if x != nil {
		return x.Tasks
	}
	return nil
}

type UpdateState_K8SEndpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodepool      string                 `protobuf:"bytes,1,opt,name=nodepool,proto3" json:"nodepool,omitempty"`
	Node          string                 `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateState_K8SEndpoint) Reset() {
	*x = UpdateState_K8SEndpoint{}
	mi := &file_spec_manifest_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateState_K8SEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateState_K8SEndpoint) ProtoMessage() {}

func (x *UpdateState_K8SEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateState_K8SEndpoint.ProtoReflect.Descriptor instead.
func (*UpdateState_K8SEndpoint) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{18, 0}
}

func (x *UpdateState_K8SEndpoint) GetNodepool() string {
	if x != nil {
		return x.Nodepool
	}
	return ""
}

func (x *UpdateState_K8SEndpoint) GetNode() string {
	if x != nil {
		return x.Node
	}
	return ""
}

type UpdateState_LbEndpoint struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	State             ApiEndpointChangeState `protobuf:"varint,1,opt,name=state,proto3,enum=spec.ApiEndpointChangeState" json:"state,omitempty"`
	CurrentEndpointId string                 `protobuf:"bytes,2,opt,name=currentEndpointId,proto3" json:"currentEndpointId,omitempty"`
	DesiredEndpointId string                 `protobuf:"bytes,3,opt,name=desiredEndpointId,proto3" json:"desiredEndpointId,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *UpdateState_LbEndpoint) Reset() {
	*x = UpdateState_LbEndpoint{}
	mi := &file_spec_manifest_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateState_LbEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateState_LbEndpoint) ProtoMessage() {}

func (x *UpdateState_LbEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateState_LbEndpoint.ProtoReflect.Descriptor instead.
func (*UpdateState_LbEndpoint) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{18, 1}
}

func (x *UpdateState_LbEndpoint) GetState() ApiEndpointChangeState {
	if x != nil {
		return x.State
	}
	return ApiEndpointChangeState_NoChange
}

func (x *UpdateState_LbEndpoint) GetCurrentEndpointId() string {
	if x != nil {
		return x.CurrentEndpointId
	}
	return ""
}

func (x *UpdateState_LbEndpoint) GetDesiredEndpointId() string {
	if x != nil {
		return x.DesiredEndpointId
	}
	return ""
}

type DeleteState_K8S struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// if set, the whole k8s cluster and all of its attached
	// loadbalancers should be destroyed.
	Destroy bool `protobuf:"varint,1,opt,name=destroy,proto3" json:"destroy,omitempty"`
	// if 'destroy' is not set, the deletion process should look at
	// the specifies nodepools and their nodes which should be deleted.
	Nodepools     map[string]*DeletedNodes `protobuf:"bytes,2,rep,name=nodepools,proto3" json:"nodepools,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteState_K8S) Reset() {
	*x = DeleteState_K8S{}
	mi := &file_spec_manifest_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteState_K8S) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteState_K8S) ProtoMessage() {}

func (x *DeleteState_K8S) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteState_K8S.ProtoReflect.Descriptor instead.
func (*DeleteState_K8S) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{19, 0}
}

func (x *DeleteState_K8S) GetDestroy() bool {
	if x != nil {
		return x.Destroy
	}
	return false
}

func (x *DeleteState_K8S) GetNodepools() map[string]*DeletedNodes {
	if x != nil {
		return x.Nodepools
	}
	return nil
}

type DeleteState_LoadBalancer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id of the loadbalancer.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// if set, the whole loadbalancer cluster will be destroyed.
	Destroy bool `protobuf:"varint,2,opt,name=destroy,proto3" json:"destroy,omitempty"`
	// if 'destroy' is not set, the deletion process should look at
	// the specifies nodepools and their nodes which should be deleted.
	Nodepools     map[string]*DeletedNodes `protobuf:"bytes,3,rep,name=nodepools,proto3" json:"nodepools,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteState_LoadBalancer) Reset() {
	*x = DeleteState_LoadBalancer{}
	mi := &file_spec_manifest_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteState_LoadBalancer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteState_LoadBalancer) ProtoMessage() {}

func (x *DeleteState_LoadBalancer) ProtoReflect() protoreflect.Message {
	mi := &file_spec_manifest_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteState_LoadBalancer.ProtoReflect.Descriptor instead.
func (*DeleteState_LoadBalancer) Descriptor() ([]byte, []int) {
	return file_spec_manifest_proto_rawDescGZIP(), []int{19, 1}
}

func (x *DeleteState_LoadBalancer) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DeleteState_LoadBalancer) GetDestroy() bool {
	if x != nil {
		return x.Destroy
	}
	return false
}

func (x *DeleteState_LoadBalancer) GetNodepools() map[string]*DeletedNodes {
	if x != nil {
		return x.Nodepools
	}
	return nil
}

var File_spec_manifest_proto protoreflect.FileDescriptor

const file_spec_manifest_proto_rawDesc = "" +
	"\n" +
	"\x13spec/manifest.proto\x12\x04spec\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x13spec/nodepool.proto\x1a\x0espec/dns.proto\"\x9c\x02\n" +
	"\x06Config\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12/\n" +
	"\x06k8sCtx\x18\x03 \x01(\v2\x17.spec.KubernetesContextR\x06k8sCtx\x12*\n" +
	"\bmanifest\x18\x04 \x01(\v2\x0e.spec.ManifestR\bmanifest\x126\n" +
	"\bclusters\x18\x05 \x03(\v2\x1a.spec.Config.ClustersEntryR\bclusters\x1aO\n" +
	"\rClustersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spec.ClusterStateR\x05value:\x028\x01\"\xd0\x01\n" +
	"\bManifest\x12\x10\n" +
	"\x03raw\x18\x01 \x01(\tR\x03raw\x12\x1a\n" +
	"\bchecksum\x18\x02 \x01(\fR\bchecksum\x120\n" +
	"\x13lastAppliedChecksum\x18\x03 \x01(\fR\x13lastAppliedChecksum\x12*\n" +
	"\x05state\x18\x04 \x01(\x0e2\x14.spec.Manifest.StateR\x05state\"8\n" +
	"\x05State\x12\v\n" +
	"\aPending\x10\x00\x12\r\n" +
	"\tScheduled\x10\x01\x12\b\n" +
	"\x04Done\x10\x02\x12\t\n" +
	"\x05Error\x10\x03\"\xae\x01\n" +
	"\fClusterState\x12(\n" +
	"\acurrent\x18\x01 \x01(\v2\x0e.spec.ClustersR\acurrent\x12(\n" +
	"\adesired\x18\x02 \x01(\v2\x0e.spec.ClustersR\adesired\x12$\n" +
	"\x06events\x18\x03 \x01(\v2\f.spec.EventsR\x06events\x12$\n" +
	"\x05state\x18\x04 \x01(\v2\x0e.spec.WorkflowR\x05state\"i\n" +
	"\bClusters\x12\"\n" +
	"\x03k8s\x18\x01 \x01(\v2\x10.spec.K8sclusterR\x03k8s\x129\n" +
	"\rloadBalancers\x18\x02 \x01(\v2\x13.spec.LoadBalancersR\rloadBalancers\"<\n" +
	"\rLoadBalancers\x12+\n" +
	"\bclusters\x18\x01 \x03(\v2\x0f.spec.LBclusterR\bclusters\"E\n" +
	"\x11KubernetesContext\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\"\xc4\x02\n" +
	"\bWorkflow\x12*\n" +
	"\x05stage\x18\x01 \x01(\x0e2\x14.spec.Workflow.StageR\x05stage\x12-\n" +
	"\x06status\x18\x02 \x01(\x0e2\x15.spec.Workflow.StatusR\x06status\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\"\x8a\x01\n" +
	"\x05Stage\x12\b\n" +
	"\x04NONE\x10\x00\x12\x0f\n" +
	"\vTERRAFORMER\x10\x01\x12\f\n" +
	"\bANSIBLER\x10\x02\x12\x0f\n" +
	"\vKUBE_ELEVEN\x10\x03\x12\t\n" +
	"\x05KUBER\x10\x04\x12\x17\n" +
	"\x13DESTROY_TERRAFORMER\x10\a\x12\x11\n" +
	"\rDESTROY_KUBER\x10\b\x12\x10\n" +
	"\fDELETE_NODES\x10\t\".\n" +
	"\x06Status\x12\b\n" +
	"\x04DONE\x10\x00\x12\t\n" +
	"\x05ERROR\x10\x01\x12\x0f\n" +
	"\vIN_PROGRESS\x10\x02\"\xe2\x01\n" +
	"\n" +
	"K8scluster\x123\n" +
	"\vclusterInfo\x18\x01 \x01(\v2\x11.spec.ClusterInfoR\vclusterInfo\x12\x18\n" +
	"\anetwork\x18\x02 \x01(\tR\anetwork\x12\x1e\n" +
	"\n" +
	"kubeconfig\x18\x03 \x01(\tR\n" +
	"kubeconfig\x12\x1e\n" +
	"\n" +
	"kubernetes\x18\x04 \x01(\tR\n" +
	"kubernetes\x12E\n" +
	"\x11installationProxy\x18\x05 \x01(\v2\x17.spec.InstallationProxyR\x11installationProxy\"\xcb\x01\n" +
	"\tLBcluster\x123\n" +
	"\vclusterInfo\x18\x01 \x01(\v2\x11.spec.ClusterInfoR\vclusterInfo\x12 \n" +
	"\x05roles\x18\x02 \x03(\v2\n" +
	".spec.RoleR\x05roles\x12\x1b\n" +
	"\x03dns\x18\x03 \x01(\v2\t.spec.DNSR\x03dns\x12 \n" +
	"\vtargetedK8s\x18\x04 \x01(\tR\vtargetedK8s\x12(\n" +
	"\x0fusedApiEndpoint\x18\x05 \x01(\bR\x0fusedApiEndpoint\"c\n" +
	"\vClusterInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\tR\x04hash\x12,\n" +
	"\tnodePools\x18\x05 \x03(\v2\x0e.spec.NodePoolR\tnodePools\"]\n" +
	"\x11InstallationProxy\x12\x12\n" +
	"\x04mode\x18\x01 \x01(\tR\x04mode\x12\x1a\n" +
	"\bendpoint\x18\x02 \x01(\tR\bendpoint\x12\x18\n" +
	"\anoProxy\x18\x03 \x01(\tR\anoProxy\"p\n" +
	"\tProxyEnvs\x12\x1d\n" +
	"\x02op\x18\x01 \x01(\x0e2\r.spec.ProxyOpR\x02op\x12\"\n" +
	"\fhttpProxyUrl\x18\x02 \x01(\tR\fhttpProxyUrl\x12 \n" +
	"\vnoProxyList\x18\x03 \x01(\tR\vnoProxyList\"\xee\x02\n" +
	"\x04Role\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12\x12\n" +
	"\x04port\x18\x03 \x01(\x05R\x04port\x12\x1e\n" +
	"\n" +
	"targetPort\x18\x04 \x01(\x05R\n" +
	"targetPort\x12 \n" +
	"\vtargetPools\x18\a \x03(\tR\vtargetPools\x12*\n" +
	"\broleType\x18\x06 \x01(\x0e2\x0e.spec.RoleTypeR\broleType\x12/\n" +
	"\bsettings\x18\b \x01(\v2\x13.spec.Role.SettingsR\bsettings\x1a\x82\x01\n" +
	"\bSettings\x12$\n" +
	"\rproxyProtocol\x18\x01 \x01(\bR\rproxyProtocol\x12&\n" +
	"\x0estickySessions\x18\x02 \x01(\bR\x0estickySessions\x12(\n" +
	"\x10envoy_admin_port\x18\x03 \x01(\x05R\x0eenvoyAdminPort\"c\n" +
	"\x06Events\x12'\n" +
	"\x06events\x18\x01 \x03(\v2\x0f.spec.TaskEventR\x06events\x12\x10\n" +
	"\x03ttl\x18\x02 \x01(\x05R\x03ttl\x12\x1e\n" +
	"\n" +
	"autoscaled\x18\x03 \x01(\bR\n" +
	"autoscaled\"\xe1\x01\n" +
	"\tTaskEvent\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12!\n" +
	"\x05event\x18\x03 \x01(\x0e2\v.spec.EventR\x05event\x12\x1e\n" +
	"\x04task\x18\x04 \x01(\v2\n" +
	".spec.TaskR\x04task\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12%\n" +
	"\aonError\x18\a \x01(\v2\v.spec.RetryR\aonError\"\xe0\x02\n" +
	"\x05Retry\x12,\n" +
	"\x06repeat\x18\x03 \x01(\v2\x12.spec.Retry.RepeatH\x00R\x06repeat\x122\n" +
	"\brollback\x18\x04 \x01(\v2\x14.spec.Retry.RollbackH\x00R\brollback\x1a\xbb\x01\n" +
	"\x06Repeat\x12+\n" +
	"\x04kind\x18\x01 \x01(\x0e2\x17.spec.Retry.Repeat.KindR\x04kind\x12 \n" +
	"\vcurrentTick\x18\x02 \x01(\rR\vcurrentTick\x12\x1c\n" +
	"\tstopAfter\x18\x03 \x01(\rR\tstopAfter\x12\x1e\n" +
	"\n" +
	"retryAfter\x18\x04 \x01(\rR\n" +
	"retryAfter\"$\n" +
	"\x04Kind\x12\v\n" +
	"\aENDLESS\x10\x00\x12\x0f\n" +
	"\vEXPONENTIAL\x10\x01\x1a1\n" +
	"\bRollback\x12%\n" +
	"\x05tasks\x18\x01 \x03(\v2\x0f.spec.TaskEventR\x05tasksB\x04\n" +
	"\x02Do\"\xbf\x01\n" +
	"\x04Task\x123\n" +
	"\vcreateState\x18\x01 \x01(\v2\x11.spec.CreateStateR\vcreateState\x123\n" +
	"\vupdateState\x18\x02 \x01(\v2\x11.spec.UpdateStateR\vupdateState\x123\n" +
	"\vdeleteState\x18\x03 \x01(\v2\x11.spec.DeleteStateR\vdeleteState\x12\x18\n" +
	"\aoptions\x18\x04 \x01(\x04R\aoptions\"X\n" +
	"\vCreateState\x12\"\n" +
	"\x03k8s\x18\x01 \x01(\v2\x10.spec.K8sclusterR\x03k8s\x12%\n" +
	"\x03lbs\x18\x02 \x01(\v2\x13.spec.LoadBalancersR\x03lbs\"\xe5\x03\n" +
	"\vUpdateState\x12\"\n" +
	"\x03k8s\x18\x01 \x01(\v2\x10.spec.K8sclusterR\x03k8s\x12%\n" +
	"\x03lbs\x18\x02 \x01(\v2\x13.spec.LoadBalancersR\x03lbs\x12O\n" +
	"\x12newControlEndpoint\x18\x03 \x01(\v2\x1d.spec.UpdateState.K8sEndpointH\x00R\x12newControlEndpoint\x12J\n" +
	"\x10lbEndpointChange\x18\x04 \x01(\v2\x1c.spec.UpdateState.LbEndpointH\x00R\x10lbEndpointChange\x1a=\n" +
	"\vK8sEndpoint\x12\x1a\n" +
	"\bnodepool\x18\x01 \x01(\tR\bnodepool\x12\x12\n" +
	"\x04node\x18\x02 \x01(\tR\x04node\x1a\x9c\x01\n" +
	"\n" +
	"LbEndpoint\x122\n" +
	"\x05state\x18\x01 \x01(\x0e2\x1c.spec.ApiEndpointChangeStateR\x05state\x12,\n" +
	"\x11currentEndpointId\x18\x02 \x01(\tR\x11currentEndpointId\x12,\n" +
	"\x11desiredEndpointId\x18\x03 \x01(\tR\x11desiredEndpointIdB\x10\n" +
	"\x0eEndpointChange\"\xfa\x03\n" +
	"\vDeleteState\x12'\n" +
	"\x03k8s\x18\x01 \x01(\v2\x15.spec.DeleteState.K8sR\x03k8s\x120\n" +
	"\x03lbs\x18\x02 \x03(\v2\x1e.spec.DeleteState.LoadBalancerR\x03lbs\x1a\xb5\x01\n" +
	"\x03K8s\x12\x18\n" +
	"\adestroy\x18\x01 \x01(\bR\adestroy\x12B\n" +
	"\tnodepools\x18\x02 \x03(\v2$.spec.DeleteState.K8s.NodepoolsEntryR\tnodepools\x1aP\n" +
	"\x0eNodepoolsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spec.DeletedNodesR\x05value:\x028\x01\x1a\xd7\x01\n" +
	"\fLoadBalancer\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\adestroy\x18\x02 \x01(\bR\adestroy\x12K\n" +
	"\tnodepools\x18\x03 \x03(\v2-.spec.DeleteState.LoadBalancer.NodepoolsEntryR\tnodepools\x1aP\n" +
	"\x0eNodepoolsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spec.DeletedNodesR\x05value:\x028\x01\"V\n" +
	"\fDeletedNodes\x12\x14\n" +
	"\x05nodes\x18\x01 \x03(\tR\x05nodes\x120\n" +
	"\x13keepNodePoolIfEmpty\x18\x02 \x01(\bR\x13keepNodePoolIfEmpty**\n" +
	"\aProxyOp\x12\b\n" +
	"\x04NONE\x10\x00\x12\f\n" +
	"\bMODIFIED\x10\x01\x12\a\n" +
	"\x03OFF\x10\x02*&\n" +
	"\bRoleType\x12\r\n" +
	"\tApiServer\x10\x00\x12\v\n" +
	"\aIngress\x10\x01*\x1e\n" +
	"\vClusterType\x12\a\n" +
	"\x03K8s\x10\x00\x12\x06\n" +
	"\x02LB\x10\x01*8\n" +
	"\x05Event\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\n" +
	"\n" +
	"\x06CREATE\x10\x01\x12\n" +
	"\n" +
	"\x06UPDATE\x10\x02\x12\n" +
	"\n" +
	"\x06DELETE\x10\x03*\x83\x01\n" +
	"\x16ApiEndpointChangeState\x12\f\n" +
	"\bNoChange\x10\x00\x12\x19\n" +
	"\x15AttachingLoadBalancer\x10\x01\x12\x19\n" +
	"\x15DetachingLoadBalancer\x10\x02\x12\x13\n" +
	"\x0fEndpointRenamed\x10\x03\x12\x10\n" +
	"\fMoveEndpoint\x10\x04B)Z'github.com/berops/claudie/proto/pb/specb\x06proto3"

var (
	file_spec_manifest_proto_rawDescOnce sync.Once
	file_spec_manifest_proto_rawDescData []byte
)

func file_spec_manifest_proto_rawDescGZIP() []byte {
	file_spec_manifest_proto_rawDescOnce.Do(func() {
		file_spec_manifest_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spec_manifest_proto_rawDesc), len(file_spec_manifest_proto_rawDesc)))
	})
	return file_spec_manifest_proto_rawDescData
}

var file_spec_manifest_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_spec_manifest_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_spec_manifest_proto_goTypes = []any{
	(ProxyOp)(0),                     // 0: spec.ProxyOp
	(RoleType)(0),                    // 1: spec.RoleType
	(ClusterType)(0),                 // 2: spec.ClusterType
	(Event)(0),                       // 3: spec.Event
	(ApiEndpointChangeState)(0),      // 4: spec.ApiEndpointChangeState
	(Manifest_State)(0),              // 5: spec.Manifest.State
	(Workflow_Stage)(0),              // 6: spec.Workflow.Stage
	(Workflow_Status)(0),             // 7: spec.Workflow.Status
	(Retry_Repeat_Kind)(0),           // 8: spec.Retry.Repeat.Kind
	(*Config)(nil),                   // 9: spec.Config
	(*Manifest)(nil),                 // 10: spec.Manifest
	(*ClusterState)(nil),             // 11: spec.ClusterState
	(*Clusters)(nil),                 // 12: spec.Clusters
	(*LoadBalancers)(nil),            // 13: spec.LoadBalancers
	(*KubernetesContext)(nil),        // 14: spec.KubernetesContext
	(*Workflow)(nil),                 // 15: spec.Workflow
	(*K8Scluster)(nil),               // 16: spec.K8scluster
	(*LBcluster)(nil),                // 17: spec.LBcluster
	(*ClusterInfo)(nil),              // 18: spec.ClusterInfo
	(*InstallationProxy)(nil),        // 19: spec.InstallationProxy
	(*ProxyEnvs)(nil),                // 20: spec.ProxyEnvs
	(*Role)(nil),                     // 21: spec.Role
	(*Events)(nil),                   // 22: spec.Events
	(*TaskEvent)(nil),                // 23: spec.TaskEvent
	(*Retry)(nil),                    // 24: spec.Retry
	(*Task)(nil),                     // 25: spec.Task
	(*CreateState)(nil),              // 26: spec.CreateState
	(*UpdateState)(nil),              // 27: spec.UpdateState
	(*DeleteState)(nil),              // 28: spec.DeleteState
	(*DeletedNodes)(nil),             // 29: spec.DeletedNodes
	nil,                              // 30: spec.Config.ClustersEntry
	(*Role_Settings)(nil),            // 31: spec.Role.Settings
	(*Retry_Repeat)(nil),             // 32: spec.Retry.Repeat
	(*Retry_Rollback)(nil),           // 33: spec.Retry.Rollback
	(*UpdateState_K8SEndpoint)(nil),  // 34: spec.UpdateState.K8sEndpoint
	(*UpdateState_LbEndpoint)(nil),   // 35: spec.UpdateState.LbEndpoint
	(*DeleteState_K8S)(nil),          // 36: spec.DeleteState.K8s
	(*DeleteState_LoadBalancer)(nil), // 37: spec.DeleteState.LoadBalancer
	nil,                              // 38: spec.DeleteState.K8s.NodepoolsEntry
	nil,                              // 39: spec.DeleteState.LoadBalancer.NodepoolsEntry
	(*DNS)(nil),                      // 40: spec.DNS
	(*NodePool)(nil),                 // 41: spec.NodePool
	(*timestamppb.Timestamp)(nil),    // 42: google.protobuf.Timestamp
}
var file_spec_manifest_proto_depIdxs = []int32{
	14, // 0: spec.Config.k8sCtx:type_name -> spec.KubernetesContext
	10, // 1: spec.Config.manifest:type_name -> spec.Manifest
	30, // 2: spec.Config.clusters:type_name -> spec.Config.ClustersEntry
	5,  // 3: spec.Manifest.state:type_name -> spec.Manifest.State
	12, // 4: spec.ClusterState.current:type_name -> spec.Clusters
	12, // 5: spec.ClusterState.desired:type_name -> spec.Clusters
	22, // 6: spec.ClusterState.events:type_name -> spec.Events
	15, // 7: spec.ClusterState.state:type_name -> spec.Workflow
	16, // 8: spec.Clusters.k8s:type_name -> spec.K8scluster
	13, // 9: spec.Clusters.loadBalancers:type_name -> spec.LoadBalancers
	17, // 10: spec.LoadBalancers.clusters:type_name -> spec.LBcluster
	6,  // 11: spec.Workflow.stage:type_name -> spec.Workflow.Stage
	7,  // 12: spec.Workflow.status:type_name -> spec.Workflow.Status
	18, // 13: spec.K8scluster.clusterInfo:type_name -> spec.ClusterInfo
	19, // 14: spec.K8scluster.installationProxy:type_name -> spec.InstallationProxy
	18, // 15: spec.LBcluster.clusterInfo:type_name -> spec.ClusterInfo
	21, // 16: spec.LBcluster.roles:type_name -> spec.Role
	40, // 17: spec.LBcluster.dns:type_name -> spec.DNS
	41, // 18: spec.ClusterInfo.nodePools:type_name -> spec.NodePool
	0,  // 19: spec.ProxyEnvs.op:type_name -> spec.ProxyOp
	1,  // 20: spec.Role.roleType:type_name -> spec.RoleType
	31, // 21: spec.Role.settings:type_name -> spec.Role.Settings
	23, // 22: spec.Events.events:type_name -> spec.TaskEvent
	42, // 23: spec.TaskEvent.timestamp:type_name -> google.protobuf.Timestamp
	3,  // 24: spec.TaskEvent.event:type_name -> spec.Event
	25, // 25: spec.TaskEvent.task:type_name -> spec.Task
	24, // 26: spec.TaskEvent.onError:type_name -> spec.Retry
	32, // 27: spec.Retry.repeat:type_name -> spec.Retry.Repeat
	33, // 28: spec.Retry.rollback:type_name -> spec.Retry.Rollback
	26, // 29: spec.Task.createState:type_name -> spec.CreateState
	27, // 30: spec.Task.updateState:type_name -> spec.UpdateState
	28, // 31: spec.Task.deleteState:type_name -> spec.DeleteState
	16, // 32: spec.CreateState.k8s:type_name -> spec.K8scluster
	13, // 33: spec.CreateState.lbs:type_name -> spec.LoadBalancers
	16, // 34: spec.UpdateState.k8s:type_name -> spec.K8scluster
	13, // 35: spec.UpdateState.lbs:type_name -> spec.LoadBalancers
	34, // 36: spec.UpdateState.newControlEndpoint:type_name -> spec.UpdateState.K8sEndpoint
	35, // 37: spec.UpdateState.lbEndpointChange:type_name -> spec.UpdateState.LbEndpoint
	36, // 38: spec.DeleteState.k8s:type_name -> spec.DeleteState.K8s
	37, // 39: spec.DeleteState.lbs:type_name -> spec.DeleteState.LoadBalancer
	11, // 40: spec.Config.ClustersEntry.value:type_name -> spec.ClusterState
	8,  // 41: spec.Retry.Repeat.kind:type_name -> spec.Retry.Repeat.Kind
	23, // 42: spec.Retry.Rollback.tasks:type_name -> spec.TaskEvent
	4,  // 43: spec.UpdateState.LbEndpoint.state:type_name -> spec.ApiEndpointChangeState
	38, // 44: spec.DeleteState.K8s.nodepools:type_name -> spec.DeleteState.K8s.NodepoolsEntry
	39, // 45: spec.DeleteState.LoadBalancer.nodepools:type_name -> spec.DeleteState.LoadBalancer.NodepoolsEntry
	29, // 46: spec.DeleteState.K8s.NodepoolsEntry.value:type_name -> spec.DeletedNodes
	29, // 47: spec.DeleteState.LoadBalancer.NodepoolsEntry.value:type_name -> spec.DeletedNodes
	48, // [48:48] is the sub-list for method output_type
	48, // [48:48] is the sub-list for method input_type
	48, // [48:48] is the sub-list for extension type_name
	48, // [48:48] is the sub-list for extension extendee
	0,  // [0:48] is the sub-list for field type_name
}

func init() { file_spec_manifest_proto_init() }
func file_spec_manifest_proto_init() {
	if File_spec_manifest_proto != nil {
		return
	}
	file_spec_nodepool_proto_init()
	file_spec_dns_proto_init()
	file_spec_manifest_proto_msgTypes[15].OneofWrappers = []any{
		(*Retry_Repeat_)(nil),
		(*Retry_Rollback_)(nil),
	}
	file_spec_manifest_proto_msgTypes[18].OneofWrappers = []any{
		(*UpdateState_NewControlEndpoint)(nil),
		(*UpdateState_LbEndpointChange)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spec_manifest_proto_rawDesc), len(file_spec_manifest_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   31,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_spec_manifest_proto_goTypes,
		DependencyIndexes: file_spec_manifest_proto_depIdxs,
		EnumInfos:         file_spec_manifest_proto_enumTypes,
		MessageInfos:      file_spec_manifest_proto_msgTypes,
	}.Build()
	File_spec_manifest_proto = out.File
	file_spec_manifest_proto_goTypes = nil
	file_spec_manifest_proto_depIdxs = nil
}
