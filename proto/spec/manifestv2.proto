syntax = "proto3";
package spec;
option go_package = "github.com/berops/claudie/proto/pb/spec";

import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";

import "spec/nodepool.proto";
import "spec/dns.proto";
import "spec/pass.proto";

// Config holds data for a single manifest.
message ConfigV2 {
  // version of the config.
  uint64 version = 1;
  // Config name - same as input manifest name.
  string name = 2;
  // Information related within a k8s context.
  KubernetesContextV2 k8sCtx = 3;
  // Client defined manifest.
  ManifestV2 manifest = 4;
  // Clusters parsed from the supplied manifest.
  map<string, ClusterStateV2> clusters = 5;
}

message ManifestV2 {
  enum State {
    Pending = 0;
    Scheduled = 1;
    Done = 2;
    Error = 3;
  }

  string raw = 1;
  bytes checksum = 2;
  bytes lastAppliedChecksum = 3;
  State state = 4;
}

message ClusterStateV2 {
  ClustersV2 current = 1;
  WorkflowV2 state = 4;
  TaskEventV2 inFlight = 5;
}

message ClustersV2 {
  K8sclusterV2 k8s = 1;
  LoadBalancersV2 loadBalancers = 2;
}

message LoadBalancersV2 {
  repeated LBclusterV2 clusters = 1;
}

message KubernetesContextV2 {
  // name represents the input manifest resource name in Kubernetes
  string name = 1;
  // namespace represents the input manifest resource namespace in Kubernetes
  string namespace = 2;
}

message WorkflowV2 {
  enum Status {
    // DONE indicates that the workflow for a scheduled [Task] has finished.
    DONE = 0;

    // ERROR indicates that an error occurred while processing the scheduled [Task]
    ERROR = 1;

    // IN_PROGRESS indicates that the [Task] is currently being worked on.
    IN_PROGRESS = 2;

    // WAIT_FOR_PICKUP indicates that new a new [Task] was created or moved to
    // the next stage to be worked on.
    WAIT_FOR_PICKUP = 3;
  }

  Status status = 2;
  // additional information describing the state.
  string description = 3;
}

// K8scluster represents a single kubernetes cluster specified in the manifest.
message K8sclusterV2 {
  // General info about the cluster.
  ClusterInfoV2 clusterInfo = 1;
  // Network range for the VPN.
  string network = 2;
  // Kubeconfig of the cluster.
  string kubeconfig = 3;
  // Kubernetes version.
  string kubernetes = 4;
  // General information about a proxy used to build a K8s cluster.
  InstallationProxyV2 installationProxy = 5;
}

// LBcluster represents a single load balancer cluster specified in the
// manifest.
message LBclusterV2 {
  // General info about the cluster.
  ClusterInfoV2 clusterInfo = 1;
  // Array of Load balancer roles.
  repeated RoleV2 roles = 2;
  // DNS information.
  DNS dns = 3;
  // Kubernetes cluster name of the cluster this load balancer is attached to.
  string targetedK8s = 4;
  // usedApiEndpoint signals which LB is actually used as the api endpoint.
  // Claudie manifest validation does not allow for multiple API endpoints
  // to be present, however. Internally claudie can deal with more loadbalancers
  // that have the API role, this is due to the creation of intermediate representation
  // which always add new infrastructure before making any further changes.
  // To recognize which of them is actually used this field was added.
  bool usedApiEndpoint = 5;
}

// ClusterInfo holds general information about the clusters.
message ClusterInfoV2 {
  // Name of the cluster.
  string name = 1;
  // Random hash of the cluster.
  string hash = 2;
  // Array of node pools this cluster is made of.
  repeated NodePool nodePools = 5;
}

// InstallationProxy holds general information about a proxy used to build a K8s cluster.
message InstallationProxyV2 {
  // Proxy installation mode.
  string mode = 1;
  // Proxy endpoint used to access the proxy.
  string endpoint = 2;
  // NoProxy is a comma-separated list of values that will be added to the default list of NoProxies used by Claudie.
  //
  // The default no proxy list is: 127.0.0.1/8,localhost,cluster.local,10.244.0.0/16,10.96.0.0/12"
  // Any values specified will be appended to the end of the default NoProxy list.
  // This field only has an effect if the Proxy is turned on.
  string noProxy = 3;
}

// Role represents a single loadbalancer role from the manifest.
message RoleV2 {
  message Settings {
    bool proxyProtocol = 1;
    bool stickySessions = 2;

    // required port for the envoy admin interface,
    // on change will issue restart of the envoy proxy.
    int32  envoy_admin_port = 3;
  }
  // Name of the role.
  string name = 1;
  // Protocol that load balancer uses to forward traffic. ["tcp", "udp"]
  string protocol = 2;
  // Port that load balancer will forward from.
  int32 port = 3;
  // Port that load balancer will forward to.
  int32 targetPort = 4;
  // Targeted nodes in Kubernetes clusters.
  repeated string targetPools = 7;
  // Type of the role.
  RoleTypeV2 roleType = 6;
  // Additional settings for the role.
  Settings settings = 8;
}

// RoleType specifies the type of the role.
enum RoleTypeV2 {
  // API server load balancer.
  ApiServer_V2 = 0;
  // Ingress load balancer.
  Ingress_V2 = 1;
}

enum EventV2 {
  UNKNOWN_V2 = 0;
  CREATE_V2 = 1;
  UPDATE_V2 = 2;
  DELETE_V2 = 3;
}

message TaskEventV2 {
  string id = 1;
  google.protobuf.Timestamp timestamp = 2;
  EventV2 event = 3;
  TaskV2 task = 4;
  string description = 5;
  RetryV2 onError = 6;

  // Pipeline stages of the task through which it has to pass
  // to be considered as done.
  repeated Stage pipeline = 7;

  // Index into the currently to be worked on pipeline stage.
  uint32 currentStage = 8;
}

message RetryV2 {
  message Repeat {
    enum Kind {
      ENDLESS = 0;
      EXPONENTIAL = 1;
    }
    Kind kind = 1;
    // currentTick specifies the current number of ticks.
    // A tick is an regular interval at which manifests are being checked.
    // to check the Tick timeout see: manager/internal/service/watchers.go
    uint32 currentTick = 2;
    // stopAfter specifies the maximum number of ticks, after reaching this value the manifest will be rescheduled
    // for the last time before giving up.
    uint32 stopAfter = 3;
    // retryAfter specifies the number of ticks to wait before rescheduling the manifest again.
    // this value will be set to the value of currentTick after it is updated.
    uint32 retryAfter = 4;
  }
  message Rollback {
    repeated TaskEventV2 tasks = 1;
  }

  oneof Do {
    Repeat repeat = 3;
    Rollback rollback = 4;
  }
}


enum ApiEndpointChangeStateV2 {
  // NoChange represents the 1st case - no change is needed as the LB cluster is currently
  // attached and the desired spec contains no changes.
  NoChangeV2 = 0;

  // AttachingLoadBalancer represents 2nd case - the K8s cluster previously
  // didn't have an LB cluster attached and the ports needed to communicate with the API server
  // were exposed. After attaching an LB cluster to the existing K8s cluster the ports
  // were closed and are no longer accessible, and thus we need to change the API endpoint.
  AttachingLoadBalancerV2 = 1;

  // DetachingLoadBalancer represents 3rd. case - the K8s cluster had an existing
  // LB cluster attached but the new state removed the LB cluster and thus the API endpoint
  // needs to be changed back to one of the control nodes of the cluster.
  DetachingLoadBalancerV2 = 2;

  // EndpointRenamed represents the 4th. case - the K8s cluster has an existing
  // LB cluster attached and also keeps it but the endpoint has changed in the desired state.
  EndpointRenamedV2 = 3;

  // MoveEndpoint represents the 5th. case - the K8s cluster has an existing
  // LB cluster attached, but it will be switched to a different LB cluster
  // in the desired state.
  MoveEndpointV2 = 4;
}

// Creates a new kubernetes cluster with the attached [LBcluster], if any.
message CreateV2{
    // The desired state of the kuberenetes cluster to create.
    //
    // This field is required to be present.
    K8sclusterV2 k8s = 2;

    // The desired state of the LoadBalancers attached to the
    // kubernetes cluster to create.
    //
    // This field is optional, if the kuberentes cluster does not have
    // any loadbalacners.
    repeated LBclusterV2 loadBalancers = 3;
}

message UpdateV2 {
    // State is the current state as known by the Manager service that is continiously
    // updated and merged into the [Update] message as it traverses the build pipeline.
    message State {
        // The state of the kubernetes cluster to update.
        K8sclusterV2 k8s = 1;
        // The state of the loadbalancers to update.
        repeated LBclusterV2 loadBalancers = 2;
    }

    message None {}

    // TerraformerAddLoadBalancer is a message that once processed
    // by the Terraformer service and a result is send back to the
    // Manager, the manager will consume the message further stages
    // will only have a [AddedLoadBalancer] message to process.
    //
    // New, "desired", state needs only to be present in the terraformer
    // stage and all other services need to only see what has been done
    // and ocasionally index the loadbalancer, which will already be present
    // in the [State] of the [Update] message.
    message TerraformerAddLoadBalancer { LBclusterV2 handle = 1; }
    message AddedLoadBalancer { string handle = 1; }

    // TerraformerReconcileLoadBalancer is a message that once processed
    // by the Terraformer service and a result is send back to the Manager,
    // it will consume the message and further stages will only have a
    // [ReconciledLoadBalancer] message to process.
    //
    // New, "desired", state needs only to be present in the terraformer
    // stage and all other services need to only see what has been done and
    // occasionally index the loadbalancer, which will already be present
    // in the [State] of the [Update] message.
    message TerraformerReconcileLoadBalancer { LBclusterV2 handle = 2; }
    message ReconciledLoadBalancer { string handle = 1; }

    // TerraformerReplaceDns is a message that once processed by the
    // Terraformer service and a result is send back to the Manager,
    // it will consume the message and further stages will only have
    // a [ReplacedDns] message to process.
    //
    // New, "desired", state needs only to be present in the terraformer
    // stage and all other services need to only see what has been done and
    // occasionally index the LoadBalancer, which will already be present
    // in the [State] of the [Update] message.
    message TerraformerReplaceDns {
        // Loadbalancer ID to which the new [Dns] is going to created for.
        string handle = 1;

        // The new dns to replace the old within [LoadBalancerId].
        DNS dns = 2;

        // If the [Dns] is part of a Api loadbalancer this
        // field will be set to give extra information for
        // when changing the Api endpoint from the old to
        // the new.
        optional string oldApiEndpoint = 3;
    }
    message ReplacedDns {
        string handle = 1;
        optional string oldApiEndpoint = 2;
    }

    // DeleteLoadBalancer works with the [State] that is part of the [Update]
    // message, thus no "message consuming" needs to happen.
    message DeleteLoadBalancer { string handle = 1; }

    // ApiEndpoint works with the [State] that is part of the [Update] message
    // thus no "message consuming" needs to happen.
    message ApiEndpoint {
        ApiEndpointChangeStateV2 state = 1;
        string currentEndpointId = 2;
        string desiredEndpointId = 3;
    }

    // K8sOnlyApiEndpoint works with the [State] that is part of the [Update]
    // message, thus no "message consuming" needs to happen.
    message K8sOnlyApiEndpoint {
        string nodepool = 1;
        string node = 2;
    }

    // ApiPortOnCluster works with the [State] that is part of the [Update] message
    // thus no "message consuming" needs to happen.
    message ApiPortOnCluster { bool open = 1; }

    // AnsiblerReplaceProxySettings is a message that once processed
    // by the Ansibler service and a result is send back to the Manager,
    // it will consume the message and further stages will only have
    // a [ReplacedProxySettings] message to process.
    //
    // New, "desired", state needs only to be present in the ansibler
    // stage and all other services need to only see what has been done
    // which will already be present in the [State] of the [Update] message.
    message AnsiblerReplaceProxySettings { InstallationProxyV2 proxy = 1; }
    message ReplacedProxySettings {}


    // UpgradeVersion works with the [State] that is part of the [Update]
    // message, thus no "message consuming" needs to happen.
    message UpgradeVersion { string version = 1;}

    // KuberPatchNodes is a message that once processed by the Kuber service
    // and a result is send back to the Manager, it will consume the message
    // and further stages will only have a [PatchedNodes] message to process.
    //
    // New, "desired", state needs only to be present in the kuber stage and
    // all other services need to only see what has been done which will already
    // be present in the [State] of the [Update] message.
    message KuberPatchNodes {
        message ListOfTaintKeys {
            repeated spec.Taint taints = 1;
        }
        message ListOfLabelKeys {
            repeated string labels = 1;
        }
        message ListOfAnnotationKeys {
            repeated string annotations = 1;
        }
        message Batch {
            map<string, ListOfTaintKeys> taints = 1;
            map<string, ListOfAnnotationKeys> annotations = 2;
            map<string, ListOfLabelKeys> labels = 3;
        }

        Batch add = 1;
        Batch remove = 2;
    }
    message PatchedNodes {}

    // State that gets continiously updated as the task gets processed.
    State state = 1;

    // Additional information while the [Update] message is passed through
    // the build pipeline to give context what has been scheduled and what
    // to process.
    oneof Delta {
        None none = 2;

        TerraformerAddLoadBalancer tfAddLoadBalancer = 3;
        TerraformerReconcileLoadBalancer tfReconcileLoadBalancer = 4;
        TerraformerReplaceDns tfReplaceDns = 5;

        AnsiblerReplaceProxySettings ansReplaceProxy  = 10;

        KuberPatchNodes kpatchNodes = 13;

        AddedLoadBalancer addedLoadBalancer = 15;
        ReconciledLoadBalancer reconciledLoadBalancer = 16;
        ReplacedDns replacedDns = 17;
        ReplacedProxySettings replacedProxy = 18;
        PatchedNodes patchedNodes = 19;

        DeleteLoadBalancer deleteLoadBalancer = 20;

        ApiEndpoint apiEndpoint = 25;
        ApiPortOnCluster clusterApiPort = 26;
        K8sOnlyApiEndpoint k8sApiEndpoint = 27;
        UpgradeVersion upgradeVersion = 28;

    }
}

// Deletes an existing kubernetes cluster along with its attached [LBcluster], if any.
message DeleteV2{
   // The current state of the kuberentes cluster to delete.
   //
   // This field is required
   K8sclusterV2 k8s = 1;

   // The current state of the loadbalancers  to delete, that
   // are attached to the kubernetes cluster.
   //
   // This field depends on the above [k8s] field and is required if
   // the kuberentes cluster has any loadbalancers attached.
   repeated LBclusterV2 loadBalancers = 2;
}

message TaskV2 {
    oneof Do {
        CreateV2 create     = 2;
        UpdateV2 update     = 3;
        DeleteV2 delete     = 4;
    }
}

// The message that is used for the Message Queue.
message Work {
    // The task to be worked on.
    TaskV2 task = 1;

    // What exactly should be done with the task.
    repeated google.protobuf.Any passes = 2;
}

message TaskResult {
    message Error {
        enum Kind {
            FATAL = 0;
            PARTIAL = 1;
        }

        Kind kind = 1;
        string description = 2;
    }

    // None specifies that nothing should be done as a result of
    // processing a task other than acknowledging that the task
    // was processed, and thus moving to next task, if any.
    message None {}

    // UpdateState specifies the current state should be updated
    // as changes may have been done to it. All of the values
    // are optionals and the receiving end should make sense of
    // them.
    // Any non-nil value signals an update that should be handled.
    message UpdateState{
        // If the [k8s] field is set then its current state should be merged/replaced
        // with the state in this message.
        optional K8sclusterV2 k8s = 1;

        // Updates the loadbalancers that are attached to the [k8s] cluster.
        // The loadbalancers in this message should only update existing matching
        // loadbalancers and or add newly created ones.
        //
        // If any loadbalancers are missing while they're present in the current state
        // they should not be deleted, as for that there is an explicit task result [ClearState].
        optional LoadBalancersV2 loadBalancers = 2;
    }

    // ClearState specifies cluster IDs which should be cleared as changes
    // processed by a scheduled task destroyed the infrastructure.
    // Any non-nil value signals an update that should be done.
    message ClearState {
        // If the kuberentes cluster is specified than all of its loadbalancers
        // should be deleted even if they're not specified within this message.
        optional bool k8s = 1;

        // ID of the loadbalancers that should be cleared.
        repeated string loadBalancersIDs = 2;
    }

    // If the Error.Kind is FATAL no useful
    // information is stored in the result.
    // Otherwise, if error is not set or PARTIAL,
    // the result will contain valid data,.
    optional Error error = 1;

    oneof Result {
        None none = 2;
        UpdateState update = 3;
        ClearState clear = 4;
    }
}
